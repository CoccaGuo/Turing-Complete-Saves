=== components/Output 1 ===

$59663530139004* 输出


=== trans/panel_program_1_output ===

$31398283096964* 输出


=== rpg/maps/overworld/kligara ===

$78685013556649*
我的职责是监视
反应堆燃料之类的玩意


=== rpg/maps/overworld/control_panel ===

$94056033073339*
乱动这个的话
会被舰长扔出飞船吧
$20128423531070* 控制面板


=== trans/level_registers_description ===

$73800316874022* [center]设计一个电路图，使之实现该关卡所要求的指令集[/center]


=== rpg/maps/overworld/water ===

$82402577990931* 水


=== components/Output1Car ===

$12896765714603* 进位


=== components/FullAdder ===

$57559382166174* 执行 3 个输入的 1 位加法，并输出结果和溢出进位
$77669928463861* 全加器


=== trans/panel_car_output_0 ===

$21449898267446* 进位


=== misc/options ===

$49251062339706* 选项


=== misc/ide_delete_program ===

$30480928296639* 确定要删除程序“{program}”吗？
$87279416580516* 确认


=== misc/io_label_change ===

$50497979766012* 标签文本


=== levels/turing_complete ===

$15326252036920* 在之前的关卡中，只有代码能影响数据，现在也该是时候让数据来影响代码运行了。添加了条件跳转的能力后，我们的电脑就能运行任何算法，完成一切可行的计算了。
$16583885726240* 你居然成功了，地球人！我本来以为你不过是看起来很奇怪的某种无毛猿类，但你确实造出一台真正的电脑来了，挺厉害！
$10510746154639* 时钟第 1 刻时，程序元件接收的地址应为 1 。
$10317244906317* 未找到程序元件
$14587485007736* 到目前为止，我们所有的程序都只能逐字节地按顺序执行。
$19649119273248*
我们最后要完成的一项任务，是添加一种[INSTRUCTIONS]并配置相应的硬件结构，从而实现条件跳转。

当指令的最高两位被置为 [ON][ON] 时，计算机应进入条件跳转模式。在该模式下，我们将判断 3 号寄存器（REG 3）中的数值是否满足由指令中最低的 3 位所指定的条件。如果满足该条件，我们就用 0 号寄存器中的值来覆盖程序计数器的数值。
如果能够有条件地改写程序计数器，就意味着我们能够在满足特定条件时，跳过某些[INSTRUCTIONS]，或让反复运行同一组[INSTRUCTIONS]。

条件的类型如下：
[OFF] [OFF] [OFF] Never（永不跳转）
[OFF] [OFF] [ON] [color=#e49f44]REG 3[/color] = 0 时跳转
[OFF] [ON] [OFF] [color=#e49f44]REG 3[/color] < 0 时跳转
[OFF] [ON] [ON] [color=#e49f44]REG 3[/color] ≤ 0 时跳转
[ON] [OFF] [OFF] Always（必定跳转）
[ON] [OFF] [ON] [color=#e49f44]REG 3[/color] ≠ 0 时跳转
[ON] [ON] [OFF] [color=#e49f44]REG 3[/color] ≥ 0 时跳转
[ON] [ON] [ON] [color=#e49f44]REG 3[/color] > 0 时跳转

上述条件类型与已经保存在元件工坊中的条件判断组件（COND）的输出是一致的。


=== rpg/maps/unseen_fruit/wall_broke ===

$82933036983558* 破损的墙壁


=== rpg/maps/prison/snuffles ===

$38415939620256* 汪汪
$58496270566737* Snuffles
$97846640630713* 血
$18282167453919* 可怜的 Snuffles


=== levels/Second Tick ===

$14355963067874* [center]只在第二刻输出 [ON] 。[/center]
$17526582195506* 你也知道，我们进行的这一系列测试，最终的成果将是一台完整的电脑。
$15726318553190* 这是我们考虑不吃掉你的首要原因。
$19277843280528*
 [color=#b72d41][b]提示：[/b][/color]
 双击组件即可一并选中其引脚
$15296208528991* 按照我们的法律，能完成这一任务的生物会被认定为具有基本的知觉。


=== trans/manual_text_console ===

$39093856809104*
控制台是一个 80x24 的 [color=#dd6576][url=ASCII encoding]ASCII[/url][/color] 字符显示屏。该组件不通过引脚和线路进行交互，它需要通过设定监视态来和电路中的存储器建立链接：
 [img=200]dialogue/manual/Console/link_state.png[/img]

设置链接后，每次写入存储器都会带动显示屏上的字符刷新。在默认的的单色模式下，存储器的每一字节都与显示屏上显示的字符一一对应。不过，显示屏上第一个字符的位置偏移量是可以改变的。设置方法是通过左边的引脚输入具体的偏移量。如果你要制作滚屏功能，这个特性可能会比较有用。

控制台另有一个彩色显示模式。选中控制台后，显示模式可在窗口下方的面板里切换：
[img=125]dialogue/manual/Console/color_mode.png[/img]

该模式下，每个字符都需要附带额外的 3 字节前景色值和 3 字节背景色值（[color=#dd6576][url=RGB color]RGB 真彩色[/url][/color]），因而每个字符对应 7 字节的数据。不过为了与 RAM 或 ROM 的 64 位寻址计算相兼容，输入是按照 8 字节/字符对齐的。利用这个特性，你可以让控制台在单色/彩色两种模式下显示同样的字符。方法是在彩色模式下将存储器的位宽设为 8 位，在单色模式下则改为 64 位。

彩色显示模式下，输入中最低（地址最靠前）的一字节是要显示的字符，随后的 3 个字节用于指定文字前景色的 RGB 值，随后 3 个字节用于指定背景色，最后一个字节无效果（仅用于对齐偏移量）。


=== trans/level_tower_description ===

$19095794285423* 将放射性金属片重新堆叠好


=== trans/panel_lessu_description ===

$10492822526537* [center]判断表达式（输入 1 < 输入 2）是否成立[/center]


=== levels/component_factory ===

$14665712485657* 该元件面积为零，无法放置。
$17077079648771* 在“切换电路图”菜单中，你可以添加、删除自定义元件，也可以重命名已创建的元件。
$19551383617326*
欢迎来到元件工坊。你在这里创建的电路可以在稍后的计算机架构中作为自定义元件而直接使用。
自定义元件的功能和外形取决于你在此设计的电路的具体结构和布局。
$12516102012088* 当前元件面积为零，因而无法在电路中使用。请在电路图上放置元件，让电路占据一定的面积（引脚所在的格子除外）。
$14712417427860* 本关并不是一个挑战关卡，而是一个工具性关卡。你随时可以选择回到关卡选择界面，继续完成后续任务。
$15549447390000* 同一个方格内有两个输入/输出端口。由于引脚重叠，当前元件将无法使用。


=== misc/ui_panel/outputs ===

$29350436761480* 输出


=== components/Register32 ===

$65405398199118* 32 位存储单元
$22031255978461* 32 位寄存器


=== trans/panel_maker16_input ===

$17253365231801*
[right]第 1 字节
第 2 字节[/right]


=== trans/panel_switch_input ===

$27545152958344* [right]输入[/right]


=== trans/component_panel_sprite_input_description ===

$76433786063719*
[b][color=#e49f44]指令类型[/color][/b]
[code]0[/code] 无操作
[code]1[/code] [color=#e49f44]加载小贴图[/color]
[code]2[/code] [color=#e49f44]设置图片坐标[/color]


=== trans/manual_the_robot ===

$92896462984546* 机器人


=== trans/level_conditions_description ===

$62540112577327* [center]当输入数值满足给定条件时，输出 [img]dialogue/on.png[/img] ；否则输出 [img]dialogue/off.png[/img] 。[/center]


=== trans/panel_program4_output ===

$30314861365347*
输出 1
输出 2
输出 3
输出 4


=== trans/rpg_complete_chest ===

$59394224080614* [center]小鬼的宝箱[/center]


=== trans/manual_text_top_the_robot ===

$45646734925323*
机器人及其周围的物体、建筑、地貌环境会显示在关卡屏幕里。

[img=430]dialogue/screen.png[/img]


=== trans/panel_clock_input ===

$26264925364981* [right]启用 [/right]


=== misc/ui_comment ===

$69987793052607* 导线注释（单击线路）


=== trans/ide_memory_address ===

$93346467287938* 已连接的元件


=== levels/delay_level ===

$19986989895202*
所有元件都有一个延迟量。一个电路中，总的延迟量是由延迟最严重（速度最慢）的那条路径决定的。为了减小延迟量，你可以把逻辑门并行排列，使它们能同时进行运算。
在本关里，你要向我证明你能够理解这些概念。
$11246430085016* 提示：你可以通过单击右上角的沙漏图标，来开关线路上延迟量的叠加显示。
$12817338693402* 电路中的延迟量是由逻辑门的延迟量推导而来。基本逻辑门的延迟量都为 2。串行连接逻辑门后，线路的延迟量会是这些逻辑门的延迟量之和。请设计一个电路，让它包含 5 个基本逻辑门，并具有 6 的延迟量。
$17854168097855* 检验结果


=== rpg/hat_man ===

$98505468673014* 宽檐帽
$31184066972544* 妖精帽
$35778552177922* 圣诞帽
$82997731204414* 童叟无欺
$96765749209775* 这顶真好看
$97164370529682* 经典款帽子
$85998153437635*
这是伦敦警局偷来的
一般人我不告诉他
$26278098578888* 圣诞老人是谁？
$47773161384061* 这帽子，开玩笑呢
$13294635391831* 法老王冠
$82258891749699* 我的钱呢？
$79556354428080* 保安头盔
$47713748239182* 客官再来啊
$87264083929605* 傲慢不偏见
$12006162361832* 咿哈
$35453270895749* 严肃点，不许笑
$68242068712116* 棒球帽
$93275531091074* 牛仔帽
$94489310827047* 这帽子大概是被诅咒了
$30546444635339* 女式帽
$50407582286574* 警官帽
$60834004183919* 板球帽
$40995289760848* 顶级帽子
$13395135491753* 有杀气


=== components/Mul16 ===

$49880767097125* 将两路输入值相乘
$62247409328063* 16 位乘法器


=== trans/panel_dual_load_input ===

$93092890899642*
[right]读取
写入
地址
待写入数值
读取 2
地址 2[/right]


=== trans/panel_network_output_description ===

$44520675249142*
[b][color=#39aa49]事件类型[/color]（结果）[/b]
[code]0[/code] 无事件
[code]1[/code] [color=#39aa49]传入连接[/color]（连接 ID，端口号）
[code]2[/code] [color=#39aa49]成功连接[/color] 
[code]3[/code] [color=#39aa49]接收数据[/color]（连接 ID，数据，数据长度）
[code]4[/code] [color=#39aa49]关闭连接[/color]（连接 ID / 错误代码）


=== trans/panel_register16_inputs ===

$96875261858960*
[right]读取
写入
待写入数值[/right]


=== trans/options_pipette_wire ===

$96339976117958* 拾取线路颜色


=== trans/rpg_complete_flower ===

$15192250170799* [center]多密欧与咕丽叶[/center]


=== trans/panel_maker32_input ===

$93209061270494*
[right]第 1 字节
第 2 字节
第 3 字节
第 4 字节[/right]


=== dialogue/schematic_hub/share_button ===

$72402014450423* [center]上传中[/center]
$63199010304839* 分享


=== trans/level_byte_xor_description ===

$44752799134543* 对两路输入的每一位逐对执行异或（XOR）运算


=== misc/add_assembly_64bit ===

$33233688912123* [center]添加汇编别名[/center]


=== trans/level_complete_wire_comments ===

$92673421413755*
[b]线路注释[/b]
[color=#cccccc][i]在线路上添加文字注释。[/i][/color]


=== components/Mux ===

$11168613697835* 二选一选通器
$22167405631310* 8 位数据选择器


=== components/Switch32 ===

$70717074742809* 32 位开关
$93061034213009* 切换线路通断


=== trans/panel_regred_input ===

$61209423072819*
[right]读取
写入
待写入数值[/right]


=== trans/level_byte_adder_question3 ===

$88075700159266*
[right]输入进位
输入 1
输入 2[/right]


=== trans/panel_counter8_input ===

$50035967147203*
[right]步进/擦写模式
待写入的值[/right]


=== trans/schematic_new_folder_name ===

$86236104278688* 新建文件夹


=== trans/panel_output_direction ===

$89612128414294* 标签方向


=== levels/Nor GATE ===

$11362258372706*
地球上大多数生物充满了攻击性，也不知道怎么集中注意力。

要想成功通过我们的测验，你就要学会逻辑思考，不能只想着搞破坏。


=== trans/level_complete_stats ===

$65428404547905* 关卡小结


=== rpg/maps/overworld/brambert ===

$23133103699795*
我在这打工攒钱
目标是买顶级帽子


=== misc/watchable_state ===

$58678516111149* 编辑监视态


=== components/Xnor64 ===

$64937916903935* 对输入进行按位同或
$47129074382309* 64 位同或


=== levels/wide_instrucitons ===

$13709034294291* 偶数刻存储，奇数刻一次输出两个值
$17693995237077* 输出两字节
$19068760748550* 偶数刻应输出 0
$65009239162932* 正确的输出应为 {a} 和 {b}
$19203973423116* 设计电路，使之在偶数刻记录程序模块的输出值，并在奇数刻一次输出两个值。
$17409169138995* 记录一字节


=== main_scripts/input ===

$10186190492148* ALT+鼠标左键单击：移动导通孔


=== levels/bit_switch ===

$56295261249455*
如果两个元件向一根线路上同时输出了不同的结果，系统将会报错，因此不同元件的输出一般不能简单地汇流到一根输出线上。不过，有些元件有灰色的输出引脚，你可以选择是否启用它们的输出功能。如果不启用，它们就与其它线路断开，因此不输出任何东西（处于高阻态）。1 位开关就是这么一种元件。

[img]dialogue/bit_switch.png[/img]

这就意味着，多个灰色的输出引脚可以连接到同一根输出线上而不引发冲突，你只需要确保任何时候最多只启用一个输出端即可。
$42793594302151* 用 2 个非门和 2 个开关，搭建一个异或门。


=== rpg/maps/overworld/griffith ===

$55209338960432*
去史莱姆农场
收集些粘液球
$96728313107159* 好的，你收集到粘液球了
$96479154941553* 明天我要去滑雪
$22071068061213* 再找 2 个就够了
$76381947526292* 4 份粘液球应该就足够了
$79617816410767* 帮我下班吧，机器人
$53961253609599*
这桶是为待会的
晚餐准备的
$27173657446279* 等一下，什么？
$75126453723590*
不错，你已经从
史莱姆农场收集了
3 份粘液球
$31359502586908*
我的病假已经请满了
这次我需要
找一个好的借口
$37703435616461* 我有个崇高的任务
$95279523937415* 再找 3 个就够了
$76778627086258*
多亏你帮忙
我才能下班
$38680695249087*
然后去厨房
把它扔进厨师背后的
炖菜锅里
$10482244323050*
现在去厨房
把它扔进厨师背后的
炖菜锅里
$24977511637567*
不错，你已经从
史莱姆农场收集了
1 份粘液球
$80959866769801*
如果我们能让我的
老大吃掉它
那问题就解决了
$21601269931093*
不错，你已经从
史莱姆农场收集了
2 份粘液球
$28681635150249* 只剩下一份了
$71867966253273*
吃点粘液球
可以让你心情愉悦


=== rpg/maps/prison/dr_rakoo ===

$62085363571678* Rakoo 博士
$41342441528477* 血
$31033960272185* 我就是著名的 Rakoo 博士


=== trans/levels_saving_bytes_text ===

$36838510526259*
[right]操作
预期存储值
预期输出
[/right]


=== components/Rol64 ===

$49017662473189* 对输入执行按位循环左移
$13677051385046* 64 位循环左移器


=== trans/level_decoder_1_RichTextLabel2 ===

$50454539040073*
[right][color=#e49f44]输入[/color]
输出 1
输出 2[/right]


=== levels/byte_shift ===

$16023356915123* 这一关的任务是，根据输入的第二个数，将输入的第一个数左移相应的位数。第二个输入不会超过 7。
$37338672894296* 将 {value} 左移 {amount} 位
$10598344098990* [center]将第一路输入值左移 x 位后输出，x 由第二路输入值给定[/center]
$23134220902659* 输入值
$16216408139965*
将一个数值[color=#e49f44]左移[/color] 1 位的意思是，将这个字节里的每一位向左平移一次，并在右侧补上 0。
例如：

将数字 90 左移 1 位：[color=#e49f44]90 shl 1[/color]
输入：[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF]
输出：[ON] [OFF] [ON] [ON] [OFF] [ON] [OFF] [OFF]

左移 3 位：[color=#e49f44]90 shl 3[/color]
输入：[OFF] [ON] [OFF] [ON] [ON] [OFF] [ON] [OFF]
输出：[ON] [ON] [OFF] [ON] [OFF] [OFF] [OFF] [OFF]
$18137790657923* 除了左移元件以外，我们还找了个实习生，让他帮你解锁了右移元件。他的工作很简单，把你的电路图镜像翻转一下就行了。
$18518173140953* 我推荐把[color=#e49f44]左移[/color]和[color=#e49f44]右移[/color]功能添加到你的计算机硬件里，以便在后续的关卡里使用。
$29295063752414* 左移量


=== trans/panel_outputlevel_enable ===

$88881816595724* [center]禁用 / 启用[/center]


=== misc/restore_overture ===

$52008982212566* 重置


=== rpg/maps/overworld/bridge ===

$70708048943630* 桥


=== trans/panel_input_down ===

$70002762618597* 下


=== rpg/maps/unseen_fruit/conveyor_belt ===

$45894441609339* 传送带


=== trans/_second_tick_RichTextLabel2 ===

$11680718497014*
[right][color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出[/right]


=== dialogue/schematic_hub/delete_comment_confirm ===

$52709446588114* 确认
$52823211591830* 确定要删除这条注释吗？


=== components/SpriteDisplay ===

$27510895774306* 多层小贴图（sprite）显示屏
$49278744667468* 精灵显示屏


=== misc/ui_panel/left_inputs ===

$16586225094516* 输入


=== trans/manual_console ===

$73523750891893* 控制台


=== trans/panel_shl8_input ===

$61388183229084*
[right]输入值
左移量[/right]


=== components/OutputCounter ===

$52247325526438* 计数器


=== components/Off ===

$61860786587357* 低电平
$72749460799924* 始终输出 [OFF]


=== misc/ide_control_link ===

$80788685813993* 机器人操作指南


=== misc/options_Score Sync ===

$45371978167502* 同步


=== trans/map_keys_to_pan ===

$26276191141664* 使用方向键平移视图


=== components/Xnor32 ===

$17419057954798* 对输入进行按位同或
$52489451755306* 32 位同或


=== trans/manual_send_otuput_robot ===

$65542429897149* [center]向输出设备发送数值，即可对机器人下达对应指令[/center]


=== components/Or3 ===

$17576327690867* 有 3 个输入引脚的或门
$99630419947500* 三路或门


=== trans/level_binary_search_description ===

$11976224688780* [center]破解保险门的密码[/center]


=== components/Output1Sum ===

$90026011029075* 总和


=== trans/rpg_complete_derpoo ===

$25534025775791* [center]安息吧，derpoo[/center]


=== trans/level_binary_programming_description ===

$66247694103179* [center]对输入加 5[/center]


=== levels/Add 5 ===

$11540713506719*
现在你可以自由地修改计算机中里的程序了。
要开始编程，请点击程序模块右上角的“编辑程序”按钮，以打开内置代码编辑器。
$19281970848639* [center]将输入值加 5 后输出（测试样例：{test}/32）。[/center]
$17770257567603* 因此我们从我们的飞船上替你找了些差事，供你练手。
$19446152707984* 请单击程序模块右上角的“编辑程序”按钮，为你的计算机编写程序。你需要控制你的电脑完成如下步骤：读取输入，将输入值加 5 ，最后将结果发送到输出设备（不必考虑溢出问题）。
$12078933051174* 只是鉴于你还不知道怎么在这台计算机上编程，目前你还没法完成这种挑战。
$11074247151096* 请留意，我们已经用一个带有存储器的自定义元件替换掉了先前固定的红色寄存器。这两者的功能是相同的。
$18134632592542* 你已经搭建好第一台计算机的硬件架构了，不过要想通过我们的测试，你还需要借助它完成走迷宫的测验。


=== trans/not_gate_click_next2 ===

$20820887361993* 点击“下一刻”按钮以检验结果


=== misc/options_keys ===

$92993941290486* Shift
$65955105101920* Numpad Enter
$15851382978562* Left
$12519478101154* End
$13781284353315* Standby
$78882003890612* TAB
$23041433375813* Launch Shortcut 6
$31504133014584* Space
$65834804441085* Open URL
$91413612191819* Launch Shortcut D
$27874359646701* Treble up
$39317622588588* Launch Shortcut E
$99716387921256* Context menu
$27726004575826* Launch Media
$68199202258305* Next song
$96347674697419* Forward
$49442994583673* Left Super key (Windows key)
$58999281424396* CMD
$59365233304896* Clear
$17795913351819* Delete
$57038840198662* CTRL
$50955698469296* Launch Shortcut 9
$63772872007214* Stop
$10929402286573* Page Down
$71982112085693* Launch Shortcut 7
$93358816396539* ↓
$28214161279082* Launch Shortcut B
$14976122209522* Insert
$83084380695531* SHIFT + TAB
$70423659540492* Launch Mail
$18970380352793* Alt
$55972860446450* Search
$81640191081376* Mute volume
$20334952085165* →
$91733527994209* Launch Shortcut 2
$73529460447236* Enter
$50389171923636* Backspace
$64108103861848* Refresh
$86957870260110* Bass down
$79228417307539* Right
$48472841971511* Favorites
$94137103361291* Play
$86664894772851* Launch Shortcut F
$57182221632160* Help
$92411601634183* Pause
$32311987309013* Back
$40801064032778* Previous song
$93394348651979* Right Hyper
$64963573823520* Print Screen
$11442487736991* SysRq
$83183843351576* Launch Shortcut 0
$74172180238771* Scroll Lock
$51594389746074* Launch Shortcut 4
$24086297669523* Volume down
$16897068982305* Right Super key (Windows key)
$67529269053604* Home page
$39382222147951* Caps Lock
$51120580663479* ESC
$66339874250985* Media record
$49947924390850* Launch Shortcut 5
$47096285951897* Page Up
$17043010993255* Stop
$47330905474433* Volume up
$40013272281231* Left Hyper
$88355661220986* Launch Shortcut C
$78473292327654* ↑
$18909108170114* Launch Shortcut A
$25372126469538* Num Lock
$54347318627968* ←
$17896149617641* Treble down
$43488085975448* Home
$11908889523442* Bass Boost
$92739814679396* Bass up
$74797401805098* Launch Shortcut 8
$91210884350615* Launch Shortcut 1
$57391159100618* Launch Shortcut 3


=== trans/panel_xor_description ===

$92999392068622* [center]对两路输入进行按位异或运算[/center]


=== trans/panel_hdd_input ===

$99603056559749*
[right]Seek
加载
保存
保存数值[/right]


=== trans/overwrite_keep_both ===

$70461062797309* 保留两者


=== trans/architecture_2 ===

$38100016313511* 处理器架构 2


=== trans/program_data_width ===

$72687692653533*
[right]数据位宽：
[/right]


=== components/Counter32 ===

$87245349851451* 32 位计数器
$92765669828982* 除非被复写，否则每一刻存储值自动增加


=== rpg/maps/prison/sign2 ===

$76218421577794* 告示牌


=== trans/panel_register8_outputs ===

$72930832545270* 输出


=== trans/options_disagree ===

$60077370372179* 不同意


=== misc/tests_run_all ===

$55533125021199* 运行全部


=== misc/instr_clone ===

$69090690657232* 复制指令


=== levels/Crude Awakening ===

$12508086025944*
我们将对你展开生命体智力测试。

测试规则很简单，造一台电脑就行。我们将会吃掉不具备这种智力的生物。祝你好运。
$16321577947087* 恭喜恭喜，你被绑架了！
$19257730429557*
信号从输入流向输出。
在窗口左上角“输入”字样下方有一个绿色图标，用于切换输入状态。
现在请点击一下这个图标，将输入设为“关”。
$17675121574388*
注意，输出也关闭了。
这是因为输入的信号已经被切断了。


=== components/NOT ===

$34453052824732* 非门
$90844421681709*
反转输入值
[table=3]
[cell]输入[/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]输出[/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== levels/byte_or ===

$10368115829346* 但事实上这不构成什么伦理问题，因为你们都是很好的野生动物，对我们来说珍惜野味是种美德。
$15923734370936*
对输入的两个字节的数据进行按位或操作（每一位分别进行逻辑或运算）并输出结果。

例如：
[code]
输入 1：[ON][ON][OFF][OFF][OFF][OFF][OFF][OFF]
输入 2：[OFF][OFF][OFF][OFF][ON][ON][OFF][OFF]
输出：  [ON][ON][OFF][OFF][ON][ON][OFF][OFF][/code]
$15226896485081* 也许你会觉得把无法通过测试的所有地球生物都吃掉是不道德的？


=== trans/level_registers_code ===

$40063003736243* [center]OR[/center]


=== trans/instrucitons_header ===

$14831276667273* [center]指令[/center]


=== trans/level_the_bus_description ===

$20464862486158* [center]将数值从正确的输入端复制到正确的输出端[/center]


=== misc/option_reset ===

$15557473522933* 重置


=== trans/level_complete_hex ===

$94261690850981*
[b]十六进制[/b]
[color=#cccccc][i]在十六进制、有符号整数和无符号整数间切换[/i][/color]


=== misc/inst_new_rule ===

$41064305626707* 新建规则


=== levels/always_on ===

$50218226879226* 你在本关里解锁了第一个手册词条。这个词条很重要，请确保自己能够充分理解其内容。
$17712385236630* 搭建一个始终输出高电平（[ON]）的电路。


=== rpg/maps/unseen_fruit/control_panel ===

$65321532772341* 番茄
$51110810065199* 橘子
$88166963001775* 西瓜
$22160541540437* 梨
$74579380431603* 金苹果
$66873855446862* 猕猴桃
$73302376080596* 西瓜
$32979920031183* 猕猴桃
$15870062259126* 黑莓
$70171621231240* 控制面板
$60591101734432* 苹果
$66897764153265* 我必须靠程序引导来按动开关
$22067281046238* 金苹果
$94493068600800* 检测到这个{fruit}前，已经出现过 2 个{fruit_plural}了。
$54127406514854* 黑莓
$94632554265850* 番茄
$37155502172032* 橘子
$84136665661115* 梨
$26638472067834* 苹果
$96743644544068* {fruit} 目前仅出现了一次！


=== dialogue/schematic_hub/delete_confirm ===

$71921976503347* 确认
$46660924781254*
确定要删除名为
“{name}”的电路图吗？


=== trans/panel_decoder1_input ===

$62550086102347* [right]输入[/right]


=== trans/level_complete_gate ===

$99373213759665*
[b]逻辑门数量[/b]
[color=#cccccc][i]现在你可以查看元件和线路的逻辑门数量了。[/i][/color]


=== components/ByteEqual ===

$35668435514829* 判断两端输入是否相等
$39369982838671* 8 位判等器


=== components/Mul64 ===

$72281597169494* 64 位乘法器
$11665562499390* 将两路输入值相乘


=== levels/binary_racer ===

$25272818268849*
[b]总结[/b]

希望你已经注意到了：
1. 每个整数的二进制表示都是唯一的。
2. 每一个数位代表的数值都是右边一位的两倍。
$16076448195257* 这关是我最喜欢的消遣小游戏。在规定时间里把十进制数转成二进制数。
$37319690622142* 干得漂亮，你的成绩达到第 {current_level} 级了。
$19111664765554*
单击切换窗口下方的数位开关，使被点亮的数字总和等于题目中给出的十进制数。

要完成本关，你至少需要连续通过 3 级。

（单击[color=#e63e5b][url=accessibility_mode]此处[/url][/color]启用不计时的辅助模式）
$11176073682097* 二进制的 {number} 如何表示？


=== components/Bidirectional64 ===

$82412839066570* 64 位双向端子
$24932613021646* 可以用于规避某些循环依赖的错误


=== rpg/maps/overworld/door4 ===

$66194643935592* 秘密门


=== trans/level_complete_profile ===

$78783902500954*
[b]在线个人资料[/b]
[color=#cccccc][i]点击主菜单中的按钮以查看在线的个人游戏档案[/i][/color]


=== rpg/maps/overworld/space ===

$70779117877705* 看这浩瀚的太空
$12015430928135* 太空


=== levels/xor_gate ===

$14093358515620*
与这种真值表对应的逻辑门被称作“异或门”（XOR gate）。本关有一定难度，如果一时半会找不到答案，不必灰心。
	
[tip]一个逻辑门的输出引脚可以连接到多个逻辑门的输入引脚上。[/tip]
$19182751521677* 在上一关中你搭建的电路在第二刻输出 [ON]。在本关中你需要搭建一个在第 2 刻和第 3 刻都输出 [ON] 的电路。


=== levels/byte_nand ===

$76462832199594* 搭建一个电路，对两个单字节输入执行按位与非运算。


=== trans/panel_network_input_description ===

$36399689035136*
[b][color=#e49f44]命令类型[/color]（参数）[/b]
[code]0[/code] 无操作
[code]1[/code] [color=#e49f44]监听[/color]（端口）
[code]2[/code] [color=#e49f44]连接[/color]（IP 地址，端口）
[code]3[/code] [color=#e49f44]发送数据[/color]（连接ID，数据，数据长度）
[code]4[/code] [color=#e49f44]关闭[/color]（连接ID）
[code]5[/code] [color=#e49f44]读取下一个事件[/color]


=== components/Maker32 ===

$82420653444614* 将四根 8 位线合并为一根 32 位线
$85308499118176* 32 位集线器


=== trans/panel_output_output_3 ===

$94657695889458* 输出 4


=== rpg/maps/prison/sign_1 ===

$88221977354540* 告示牌
$74189085130186*
上面写着：按下这个按钮
将打开牢房的门


=== dialogue/dotMatrixtext_link ===

$82486902873499*
“颜色”引脚使用第 2、3、4 个字节来生成 [url=RGB color]RGB 颜色[/url]。第一个字节未使用。
“像素”引脚使用第 2、3、4、5、6、7 个字节来选择哪些像素将被着色，其中每个位对应一个像素。仅当第 8 个字节被设置为 1 时，显示屏才会更新，它会“刷新”所做的修改并显示出来。

要刷新显示屏，“启用 X”和“启用 Y”都必须设置为“开”。


=== trans/panel_decoder3_output ===

$41412072467493* 仅一路输出激活


=== rpg/maps/prison/prision_door ===

$64702123078518* 这扇门被锁住了
$42385408716570* 门


=== misc/add_code_name ===

$57358078712675* 保存


=== components/Hdd ===

$75645507178296* 硬盘
$78558655732992* 非易失性存储器


=== ui/state_ui/title_screen/exit ===

$12639868461113* 退出


=== rpg/maps/spacial_invasion/space_rat ===

$72504258410857* 太空老鼠离得太近了
$94470860110909* 太空老鼠
$67254986543263*
如果靠编程完成这些操作
就能通过这一关了


=== trans/panel_fulladder_output ===

$18502107482550*
总和
进位


=== trans/options_waiting ===

$58990937331663* 等待中


=== misc/ui_panel/memory ===

$65362728703588* 存储器


=== trans/ide_add_assembly_header ===

$94462268558066* [center]添加汇编别名[/center]


=== trans/panel_output_output_2 ===

$33211646632666* 输出 3


=== levels/any_doubles ===

$16587030847545* 我们的科技非常先进，连叠袜子这样的事情都是机器自动完成的。但是不巧，叠袜子机上给袜子配对的检测器刚才坏掉了。
$14373083988184*
本关有 4 个输入。
有 2 个或更多的输入为 [ON] 时，输出 [ON]。

[tip]别把这一关想得太复杂。[/tip]


=== trans/panel_rom_output ===

$80688779703520* 输出


=== components/Neg64 ===

$88458190974122* 64 位取反器
$52206550732945* 将输入数值的符号反转


=== rpg/maps/unseen_fruit/door2 ===

$66022312281343* 门


=== components/DelayLine1 ===

$30487770736917* 延迟线
$38206009264853* 在下一刻输出此刻的输入值


=== misc/confirm_factory_reset ===

$65699778604521* 清空所有内容


=== components/DelayLine32 ===

$56616725618490* 在下一刻输出此刻的输入值
$49292282287971* 32位延迟线


=== components/Nand64 ===

$27197172037913* 64 位与非
$66590147372797* 逐位对两个输入进行与非运算


=== misc/run_fast ===

$54853798559740* 快速运行（右键单击：切换运行速度）


=== misc/ide ===

$80281780593326* {nr} 自定义
$33302419528314* {nr} 计数器
$57584872924662* {nr} 输出
$66077393938044* {nr} 寄存器
$57192021095756* {nr} 线路探针
$89311802272165* {nr} 1 位探针
$18255035821811* {nr} 内存


=== trans/panel_off ===

$61047424972631* 始终输出


=== component_panels/Output8zLevel ===

$35707954769868* 未启用


=== components/Nor64 ===

$17208777467974* 逐位对两个输入取或非运算
$72509242083648* 64 位或非


=== trans/panel_hdd_description ===

$28038932532386*
[center]在硬盘中，“磁头位置”决定了读取或写入操作在何处进行。从“寻道”引脚传入有符号 8 位整数，可让“磁头位置”发生移动，移动的字节数为输入数值的 8 倍。
如果你不想移动磁头，请确保“寻道”引脚输入为 0。[/center]


=== trans/panel_or_description ===

$65281182019602* [center]对两路输入进行按位或运算[/center]


=== trans/panel_input_input_3 ===

$21321167572284* 输入 4


=== levels/Delicious Order ===

$10160261151833* 首先，从输入中依次读取不同食品的美味程度。然后，按从小到大的顺序输出它们。
$16027225087666* 我们正在为银河系的食物百科全书编写有关人类食物的条目。我们的语言中没有字母表，因此百科全书中的条目是按美味程度排序的。


=== components/Equal64 ===

$34603983706314* 判断两端输入是否相等
$82876546747608* 64 位判等器


=== trans/panel_rol_input ===

$95166818170185*
[right]输入
循环偏移量[/right]


=== trans/manual_network_label ===

$90392202103470* 在此输入一个 IP，将其转换为一个整数


=== trans/manual_component_factory ===

$35460636622618* 元件工坊


=== trans/options_status ===

$35063135798145* 状态


=== trans/map_functions ===

$83960548773205* 函数


=== trans/manual_universal_gates ===

$28345532918560* 通用逻辑门


=== levels/Tower of Radioactive Alloy ===

$13757925963562* 我们想让你从旧的反应堆之中取出具有放射性的碟片，并将它们按顺序叠好。请不要将较大的碟片摞在较小的碟片之上，否则反应堆将会爆炸。
$10750976989948*
开始运行后，程序首先读入的四个数值分别代表如下含义：
disk_nr - 最大的金属盘的编号（在 2 到 4 之间）
source - 金属盘的初始位置
destination - 金属盘移动的目标位置
spare - 用于中转的空闲位置标号（既不是初始位置也不是目标）

向输出端发送不同的数值，可以控制电磁起重机进行不同的操作：
0 - 将电磁铁移动到 0 号位
1 - 将电磁铁移动到 1 号位
2 - 将电磁铁移动到 2 号位
5 - 切换电磁铁的开关状态

你也可以在代码编辑器界面里手动游玩（不计分）。使用方向键移动电磁铁，回车键切换电磁铁开关状态。
$19265994465686* 我们需要你帮忙清理一下地下室。
$35120623183961* 从 {source} 移动到 {destination}
$15855497886737*
在你的电脑中实现下面的算法：

汉诺塔（Tower of Hanoi）算法伪代码：[code][color=#87a8c8]
func move(disk_nr, source, dest, spare):
	if disk_nr is 0:
		move disk from source to dest
	else:
		move(disk_nr - 1, source, spare, dest)
		move disk from source to dest
		move(disk_nr - 1, spare, dest, source)[/color][/code]

[tip]调用函数之前，请把子函数可能改写的寄存器中的数值压入栈里，等子函数返回时再将它们从栈中弹出。这样一来，当子函数改写寄存器时，你就不会丢失这些信息。[/tip]


=== components/Input 1 Byte ===

$90785720285146* 8 位输入


=== trans/panel_probewirebit_value ===

$24213353038685* [center]监测值[/center]


=== trans/hub_type ===

$23829497228009* 类型


=== trans/manual_text_binary ===

$69488982380310*
我们在日常生活中使用的数字通常是十进制数。在任何一个十进制数的末尾添加一个 0 ，这个数字就会变为原先的 10 倍。

数字电路使用的是二进制数。在二进制数的末尾添加一个 0 ，只会使其变为原先的 2 倍。换句话讲，二进制数的每一位都代表 2 的整数次幂。[color=#c54d5e]二进制数[/color]与[color=#e49f44]十进制数[/color]的对应关系举例如下（进制用颜色区分）：
[color=#c54d5e]    1[/color] = [color=#e49f44]1[/color]
[color=#c54d5e]  10[/color] = [color=#e49f44]2[/color]
[color=#c54d5e]100[/color] = [color=#e49f44]4[/color]

要用二进制数表示十进制的 6 ，我们只需要把它写成 4 加 2 ：
[color=#c54d5e]110[/color] = [color=#e49f44]6[/color]

在二进制下，加法、乘法等运算与十进制下的规则相同，唯一的区别是进位的规则从“满十进一”改成了“满二进一”。


=== panel_sound_sound_picker ===

$73758040671294* 音符列表（点击 [i][/i] 图标以替换声音文件）


=== trans/level_alu1_description ===

$90245779080897*
[center]对输入的两个字节执行
按位与/或/与非/或非操作[/center]


=== components/Program1Red ===

$26811947547688* 可编程存储部件
$55594749714809* 程序


=== nim/backend_lib/assembler ===

$46709301132173* 第 {line} 行：“label”关键字后只能指定一个名称（例如 label jump_here）
$91607161873807* 第 {line} 行：“const”关键字后需跟随一个常量名及其数值（例如 const shoot 5）
$29335866080065* 第 {line} 行：“set_input”关键字的参数必须能转化为具体的数字
$27717388396189* 第 {line} 行：“expect”关键字后必须指定监视态的编号及其期望值
$81373400907688* 第 {line} 行：出现某种未知错误
$95834288706682* 第 {line} 行：“set_input”关键字后需要指定数值
$65326376775481* 第 {line} 行：“label”关键字后需要指定一个名称（例如 label jump_here）
$23247597342508* 第 {line} 行：“set_input”关键字在本关中无法使用。
$49738057919794* 第 {line} 行：“const”关键字后只能跟随一个常量名及其量值（例如 const shoot 5）
$54823996766711* 第 {line} 行：“expect”关键字的第二个参数无效
$15087417947547* 第 {line} 行：“expect”关键字后只能指定一个监视态和一个期望值
$39128060960831* 第 {line} 行：“expect”关键字在本关中无法使用。
$34201706604320* 第 {line} 行：“expect”关键字的第一个参数必须是数字（监视态的编号）
$80435549997833* 第 {line} 行：无效的常数


=== misc/dir_delete ===

$94436541903929* 下列的架构：{list}
$17985924005596* 该文件夹里尚有 {nr} 个电路图。
$51791491383290* 该自定义组件已被用于
$63013773025775* 确定删除“{file_name}”吗？
$38011567415872* 文件夹为空。
$57790786178566* 下列的自定义元件：{list}


=== rpg/maps/overworld/bed ===

$19781388766480* 床
$41698807327261* 我真喜欢盯着这些家具看


=== levels/little_box ===

$17142958857584* A 或 B
$12901484249817* 你能在这有限的空间里塞下 4 个字节的寄存器吗？
$14218335256117*
在我们的先进文明中，强迫囚犯做极其琐碎的工作是奴役行径，技术上讲这是不合法的。
所以我们让我们的实习生为你的组件创建了一个 256 字节的版本。
$32676754026463* 写入 {value} 并读取
$15908016538045* 待写入数值
$13765566466116* 不写入
$16196915566111* 0
$19282543476901* 1
$30856781458049* 写入 {value}
$14259545926196* A
$12306130287676*
在本关中，你需要设计一个电路，令它能向 4 个 8 位寄存器中随意[SAVE]或从中[LOAD]信息。

输入的第一个信号位决定是否[LOAD]，第二个信号位则决定是否向寄存器[SAVE]新值。另有一个 8 位的输入端子向你提供待写入的数值。
此外，我们还将给你的电路输入两个地址位，分别是 A / B 与 0 / 1。

利用这两个地址位的信号，你可以组合出 4 个不同的地址来，每个地址应该对应一个 8 位寄存器。
[i][tip]尽量在中间进行集线，并按照直角排列导线，不然布线会很乱。[/tip][/i]
[i][tip]选中元件后按空格键可以进行旋转[/tip][/i]

输出端子带有一个启用引脚。仅在[LOAD]时发送 [ON] 以启用它。
$16217965518477* B
$10891070331034* B
$18084166025569* 无操作
$13082830776248* 不读取
$17473197268827* 读取
$13555908976270* 0 或 1
$10311371309532* 写入
$16925432534232* 读取
$13644027370563* 读取
$12933801309767* A
$12291627335021* 写入


=== trans/ide_binary_header ===

$22615032668969* 二进制编辑器


=== trans/level_registers_text ===

$78241632854567*
[right][color=#e49f44]指令
输入[/color][/right]


=== trans/panel_cond_input_0 ===

$59435425554599* 第0位：


=== levels/program ===

$16693098943939*
[INSTRUCTION]输入已经被移除，我们使用程序组件取而代之。请使用计数器元件，让你的电路在每一刻从程序存储器中自动读取下一条[INSTRUCTION]。
	
请注意，你必须使用之前解锁的蓝色计时器元件，而不能使用其它自定义元件取而代之。
$19686277478479* 程序一直在输出第一个指令，你真的连接上计数器了么？


=== trans/hub_status ===

$64105077092961* 下载中…


=== trans/manual_components ===

$40288888375581* 内置元件


=== levels/byte_equal ===

$17156565273196* 当两路输入相等时，输出 [ON] 。


=== trans/panel_delayline1_output ===

$99213923469748* 输出


=== rpg/maps/overworld/blankidork ===

$19291766514049* 我们正在与叛军作战


=== trans/level_complete_stat_time ===

$39203727515285* 总用时


=== trans/level_program_text ===

$38014836341470*
[right][color=#e49f44]指令
输入[/color][/right]


=== trans/map_memory ===

$58330421958143* 存储器


=== levels/capitalize ===

$14894954428144*
本关的输入是一串用 ASCII 码（详见手册）表示的字符。这一串字符是一个行星名称的列表，每个行星的名字之间以空格（对应的数值为 32）分隔开来。你的任务是将每个单词中的首字母替换成大写形式。
输入中可能出现的字符包括小写的字母（a-z）、空格、单引号（'）和连字符（-）。
$13301617098810* 我们让实习生用人类的文字来输入星球名称，可惜他忘记将每个名称的首字母大写了。
$11647445869837* 输入：
$11201813578269* 输出：


=== ui/options/General ===

$36195388998735* 通用


=== trans/manual_text_matrix ===

$75170402412137*
[b]显示字母[/b]
5x7 像素的空间虽然小，但用于显示字母的效果还不错。在此基础上增加一行一列，这些字母排列在一起时也会很好看。

[center][img]dialogue/manual/matrix_letter.png[/img][/center]


[b]可平铺的小屏幕[/b]
旋转该组件，你就得到了一个 8x6 的像素、长宽比为 4:3 的小屏幕。将这些小块拼接起来，你便能得到大多数你想要的屏幕分辨率。这个组件上的引脚是专门针对平铺摆放进行设计的。想象一下，如果每个组件都需要用一个控制位来激活的话会发生什么：你要给每个小块屏幕专门连接 1 根线。在这种情况下，铺设屏幕所需的导线数量会随着面积的增加而成比例增加，而组件之间的布线所需的间隙也会随之增加。

[center][img]dialogue/manual/tilable_screen.png[/img][/center]

相反，如果设置两个“启用”引脚，那么要选择一整行或一整列的小屏幕，都各自只需一根线即可完成。这样一来，就可以通过这两个方向的导线的行列组合来激活阵列中的任意一个元件了。此外，显示屏所需要的其他信息也由同一根导线一并输入，这样每块显示屏只需要一格宽的空间即可完成所需的布线操作了。该元件在视觉上每条边各自多占据了半格空间，因此它们正面的显示区域可以彼此无缝拼接，背后则隐藏了一格空间，恰好可以用于走线。


=== trans/levels_counting_signals_RichTextLabel2 ===

$34604121212779*
[right]输入 1
输入 2
输入 3
输入 4[color=#e49f44]
预期输出
当前输出[/color][/right]


=== trans/levels_double_the_number ===

$41609125516676* [center]将输入的数值翻倍后输出[/center]


=== trans/panel_full_adder_input ===

$67545680105541*
[right]输入 1
输入 2
输入 3[/right]


=== trans/level_delay_level_description ===

$24326379952614* 搭建一个使用 5 个基本逻辑门并拥有 6 个单位延迟量的电路


=== trans/panel_max_data_len_max_data_length ===

$88063177433135* [right]最大数据长度[/right]


=== trans/level_spacial_invasion_description ===

$44980627299841* [center]消灭太空老鼠！[/center]


=== levels/registers ===

$10661964231175* 我把这一关中红色元件的位置锁定了，因为你的布线总是乱糟糟，没有留下足够的空间。从现在开始，你设计的这些乱七八糟的电路会在各关卡之间同步，这意味着你不再需要每关都从零开始。
$10211777161405*
以下两表分别给出了指令中的[color=#c54d5e]源[/color]及[color=#e49f44]目的[/color]所指代的存储位置：

[color=#c54d5e]源[/color]:
[OFF] [OFF] [OFF]  REG 0（0 号寄存器）
[OFF] [OFF] [ON]  REG 1（1 号寄存器）
[OFF] [ON] [OFF]  REG 2（2 号寄存器）
[OFF] [ON] [ON]  REG 3（3 号寄存器）
[ON] [OFF] [OFF]  REG 4（4 号寄存器）
[ON] [OFF] [ON]  REG 5（5 号寄存器）
[ON] [ON] [OFF]  INPUT（输入组件）
[ON] [ON] [ON]  UNUSED（未使用）

[color=#e49f44]目的[/color]:
[OFF] [OFF] [OFF]  REG 0（0 号寄存器）
[OFF] [OFF] [ON]  REG 1（1 号寄存器）
[OFF] [ON] [OFF]  REG 2（2 号寄存器）
[OFF] [ON] [ON]  REG 3（3 号寄存器）
[ON] [OFF] [OFF]  REG 4（4 号寄存器）
[ON] [OFF] [ON]  REG 5（5 号寄存器）
[ON] [ON] [OFF]  OUTPUT（输出组件）
[ON] [ON] [ON]  UNUSED（未使用）

若你想要更直观地了解要求，点击左上角的[INSTRUCTION]图标。
$15888345020710*
本关中你需要搭建一个电路，使之能够将数据从[color=#c54d5e]源[/color]复制到[color=#e49f44]目的[/color]。

这一关中，指令字节中的某些位将指定[color=#c54d5e]源[/color]和[color=#e49f44]目的[/color]所指代的寄存器或设备。

其中，第 1、2、3 位（从低到高）对应[color=#e49f44]目的[/color]，第 4、5、6 位则对应[color=#c54d5e]源[/color]。
$14823499195861* 打开顶栏的“指令集”
$14108238519744* 是时候开启你的主要项目了，从现在开始，一步步搭建 [color=#e49f44]OVERTURE[/color] 计算机架构吧。它实实在在地是一台图灵完备的机器，无论从什么角度讲都称得上是一台真正的计算机！
$14041158687959*
[color=#c54d5e]源[/color]和[color=#e49f44]目的[/color]可以是 6 个寄存器中的任意一个，我们依次将其命名为寄存器 0 （REG 0）到寄存器 5（REG 5）。

此外，关卡地图中还有一个输入组件，可以作为[color=#c54d5e]源[/color]，以及一个输出组件，可以作为[color=#e49f44]目的[/color]。


=== components/Ashr32 ===

$57867060876326* 32 位算术右移器
$77878150504241* 将输入的数值按位右移，并保持符号不变


=== misc/level_gate_manual_icon ===

$22002156022920* 解锁手册词条


=== components/DotMatrixDisplay ===

$18651725958642* 6x8 点阵显示屏
$71512568789377* 6x8像素显示屏


=== rpg/maps/overworld/fuel ===

$99170934143071* 核心燃料


=== trans/panel_and_description ===

$62144934019319* [center]对两路输入进行按位与运算[/center]


=== levels/Masking Time ===

$19351773688761* 剩余时钟刻：{ticks_left}  输入：{input}
$16810715868480* 计算输入值模 4 的结果（即输入值除以 4 的余数）。
$17375862136921*
在我们星球上每个星期有 4 天，分别是星期零，星期壹，星期贰和星期叁。我听说有的地球人会把星期贰的日子算错？
	
我对此并不感到奇怪。
$65431688078892*
本关里，你需要从输入端读取一个整数，并输出这个数除以 4 的余数（对 4 取模）。

本关的难点在于，你计算出每个结果的用时都不得超过 {ticks_per_test} 个时钟刻。

注意，你不需要对硬件作任何改动。而只需要找到快速进行模 4 计算的技巧。
如果你卡关了，可以参考这个[color=#e63e5b][url=masking_time]提示[/url][/color]。
$81055582534899* 不管怎么说，新年就要到了。我们需要你来算一下每个人的生日都在一星期里的哪一天。我会给你日期，你只需要在 {ticks_per_test} 个时钟刻内给我报上那是星期几就行。


=== components/Console ===

$66743357915699* 控制台
$16105755937680* 80x24 字符显示屏


=== rpg/maps/overworld/oozla ===

$72859292385128*
他们说可以用任意两个寄存器
进行算数操作
结果可以储存到任何地方
$41963791304712*
唉，这不过是孩子们的故事，
这样的英雄只存在于童话故事中
$91713298019390*
据说他们的计算机
每次能加载 1 个以上的字节
$43108829077557*
传说他们要创造一台
强大的计算机并用它
解决困扰着这艘船的
放射性废物问题
$60555049113315*
有人说它将会有至少
4 位的内存地址
能寻址 16 个内存位置
$52580048139802* 预言中提到了即将到来的英雄


=== components/LessI16 ===

$75600169624828* 16 位小于比较器（有符号）
$73697238171042* 判断输入 1 是否严格小于输入 2


=== trans/label_input_input_0 ===

$83039286441109* 输入 1


=== trans/component_panels_sprite_inputs ===

$89388086235988*
[right][color=#e49f44]命令类型[/color]
精灵 ID（Sprite ID）
位置（Position）
尺寸（Size）[/right]


=== trans/manual_circular_dependency ===

$40263928358112* 循环依赖


=== trans/level_constants_description ===

$34641396464207* [center]为你的计算机添加直接写入常数的功能[/center]


=== trans/panel_keyboard_right ===

$20567291616294*
键码值
按键释放


=== trans/panel_equal_output ===

$15175350110347* 输出


=== trans/panel_on ===

$77349453746493* 始终输出


=== misc/profile ===

$32835651830157* 个人资料


=== components/BeepBox ===

$16713357727925* 发声元件，最多可设置 256 种不同的音调和音色。
$11041223461254* 声音元件


=== trans/panel_sound_inputs ===

$45047777963599*
[right]音符编号
音高偏移量（有符号整数）[/right]


=== trans/panel_clock_output ===

$47697250900761* UNIX 时间戳（单位：微秒）


=== components/Bidirectional32 ===

$54631386552063* 32 位双向端子
$35105566244017* 可以用于规避某些循环依赖的错误


=== misc/specifications ===

$56390619785555* 查看指令定义
$68054407020318* 指令集


=== trans/manual_component_factory_text ===

$42847481618884*
单击左上角工具栏的按钮 [img]dialogue/manual/component_factory_icon.png[/img] 便可以打开元件工坊。

在元件工坊中，你可以创建属于你自己的元件。你为自定义元件设定下的运行逻辑将决定它的功能，你为自定义元件安排好的外观布局则将决定它的外形。元件设计图上每一个包含组件的方格都对应着元件外形上占据的一个小方块。自定义元件支持多层嵌套。

放置在元件设计图上的输入/输出元件会成为该元件的引脚。和其它内置元件一样，将自定义元件的输出引脚连接到自身的输入引脚上，就会直接被程序判定为循环依赖，哪怕元件内部的电路设计表明两者并不存在循环依赖关系也如此。这种判定方式不需要考虑元件内部的具体构造，因而能够减轻复杂电路中进行循环依赖检测的负担，但这种抽象方式偶尔也会过于严格，为设计带来一定的不便。在某些特定情况下，你可能希望程序根据元件内部的具体电路构造来进行循环依赖检测。如遇到这种情形，请使用双向端子来代替普通的输入/输出端子。这类端子允许信号双向流通，同时也允许程序深入元件内部，结合元件的具体电路设计来进行循环依赖检查。

放置在自定义元件上的探针会在它们的外观上显示其内部被监测的数值。探针可以链接到自定义元件上，因此利用多层嵌套的探针，元件内部深层埋藏的特定数据也能在最外层显示出来。包含探针的自定义元件和内置的存储器、计数器一样，可以被链接到程序模块的监视槽上。

对元件工坊而言，文件管理器本身就是元件管理器。每个元件的文件名就是游戏中的元件名，文件夹结构则直接对应着自定义元件菜单中的层级结构。


=== misc/network_update ===

$40010486743721* [center][color=#60a96b]上传失败。[/color][/center]

#  Showing what components are used in schematics in the hub
$83560387278127* 依赖项：
$86830276924898* 上传时间：
$15762392983604* 大小：

#  If the hub can't load a schematic for some reason
$76023068123024* 错误
$70694384106281* 创建者：
$81675147704214* 使用了网络元件
$98151734218561* [center][color=#60a96b]上传完成。[/color][/center]
$47639082058046* 暂无结果


=== trans/level_complete_stat_delay ===

$43118901497406* 总延迟


=== components/NetworkClient ===

$44510554000571* 网络接口
$90462653419289* 处理网络连接


=== rpg/maps/overworld/door2 ===

$40757019106897* 门


=== trans/options_animation_speed ===

$13442839894535* 导线动画速度


=== trans/levels_negative_descriptions ===

$87964635915702*
能够表示 -127~127 的所有整数：
0~127 与先前相同：
与已有加法器兼容：


=== components/Counter16 ===

$37313834107391* 除非被复写，否则每一刻存储值自动增加
$49104925799943* 16 位计数器


=== trans/panel_cond_input_1 ===

$99239506734191* 第1位：


=== trans/panel_splitter32_output ===

$18283412227212*
第 1 字节
第 2 字节
第 3 字节
第 4 字节


=== rpg/maps/overworld/barrel7 ===

$56979881178765* 这是一个桶
$19922359571673* 炖菜锅


=== components/Splitter32 ===

$90978982016052* 将一根 32 位线拆分为四根 8 位线
$24096666569346* 32 位分线器


=== dialogue/schematic_hub ===

$22639280459994* 加载中…


=== trans/panel_neg_input ===

$92219875545393* [right]输入[/right]


=== components/Program64 ===

$38310909505735* 程序
$76480303942112* 可编程存储部件


=== components/Shl64 ===

$56766765894165* 对输入进行按位左移
$37014604954362* 64 位左移器


=== misc/continue ===

$93610185550877* 继续


=== trans/level_byte_mux_description ===

$20538476756633* [center]将正确的输入值发送到输出端[/center]


=== trans/options_cluster_color ===

$77850745497963* 导线簇着色


=== trans/panel_program_1inputs_label ===

$85358271811851* [right]编辑监视态[/right]


=== nim/backend_lib/schematics ===


#  Default assembly instructions
$98784625122112*
add 68
reg0_to_reg1 129
reg0_to_reg2 130
reg3_to_out 158

#  Decoder pin name
$80846046332059* CONDITION

#  Name of lab test file (the name determines what it looks like in game, but don't the .assembly part)
$43762760711440* 3 Conditions.assembly

#  For the default OVERTURE instruction menu
$36937658066516* AND
$25378963142694* 输入 2

#  For the default OVERTURE instruction menu
$34688070019016* Compute
$48524980499900* VALUE
$23343928938611* CALCULATION
$80984147393241* OPCODE

#  For the default OVERTURE instruction menu
$41384200516164* 输入

#  For the default OVERTURE instruction menu
$89904818945500* Always
$21762287720058* Default
$52720470197560* 条件
$25947122599583* PUSH

#  For the default OVERTURE instruction menu
$58135326697989* Output

#  For the default OVERTURE instruction menu
$45098916684469* Never
$69871887031160* 输出

#  For the default OVERTURE instruction menu
$77964040770330* ADD

#  For the default OVERTURE instruction menu
$90287016519308* UNUSED
$17900992684779* 输入

#  For the default OVERTURE instruction menu
$23756602199977* NAND
$98979865390652* OUTPUT

#  For the default OVERTURE instruction menu
$52155313885654* 条件
$30360644331285* POP

#  Name of lab test file (the name determines what it looks like in game, but don't the .assembly part)
$55885017410507* 0 Immediate load.assembly

#  Name of lab test file (the name determines what it looks like in game, but don't the .assembly part)
$38851635485723* 2 Calculations.assembly

#  Name of lab test file (the name determines what it looks like in game, but don't the .assembly part)
$84575312492466* 1 Register copying.assembly

#  Default program the first time you open binary search
$28582639590579* # 如下定义跳转标签\nlabel my_label\n# 如下定义常数\nconst PI 3\n# 此外，我们还推荐你\n# 看一看手册的“汇编”页面

#  For the default OVERTURE instruction menu
$49207579633810* NOR
$97114869841400* Output
$23432943836287* 例子
$15697933732634* 指令

#  For the default OVERTURE instruction menu
$98586044504803* 复制

#  For the default OVERTURE instruction menu
$87661236574161* Immediate

#  For the default OVERTURE instruction menu
$43346201280348* SUB
$50176996454102* IMMEDIATE
$47025412277453* 输入 1
$38100656631435* COPY

#  For the default OVERTURE instruction menu
$63749396808309* OR

#  Default code seen when first opening the IDE
$46866969777934* # 注释以 # 开头\n# 示例代码：计算 1 + 1\n1\nreg0_to_reg1\nreg0_to_reg2\nadd\nreg3_to_out


=== levels/xor ===

$11589029892097* 对输入 {a} 和 {b} 的值进行按位异或
$12758156517177* 利用你的计算机中已经实现的指令功能，读取两次输入并输出两个值按位异或（XOR）的结果
$16047615798435* [center]读取两次输入并将两个值按位异或（XOR）[/center]


=== trans/level_byte_or_text ===

$99465606386164*
[right]
[color=#e49f44]输入[/color]
预期输出
当前输出
[/right]


=== trans/panel_not_output ===

$74796974148718* 输出


=== trans/manual_simulator ===

$19932404521621* 电路仿真器


=== trans/panel_output ===

$19698504808819*
总和
溢出进位


=== rpg/maps/boss_room/door2 ===

$48251720560954* 地牢门


=== levels/the_bus ===

$28468611444223* 1 号输出
$67465559416096*
本关有 2 个 8 位输入端和 2 个 8 位输出端。你的目标是将数值从指定的输入端复制到指定的输出端。

此外另有两个 1 位的输入，第一个指定你应该从哪个输入端获取数值，而第二个指定你应该将数值复制到哪个输出端。

如果你卡关了，可以参看这个[color=#e63e5b][url=the_bus]提示[/url][/color]。
$52612646660710* 0 号输入
$97971478046986* 1 号输入
$73177632038973* 0 号输出
$71428957264410* 1 号输入
$72472660427162* [center]从 {input_nr} 号输入端将数值复制到 {output_nr} 号输出端[/center]
$96958133516462* 源
$91318587712792* 目的
$72709070901789* 1 号输出
$36872979988941* 0 号输入
$33984298968523* 0 号输出
$85140574084420* [center]从正确的输入端将数值复制到正确的输出端[/center]


=== components/Ram ===

$95418291334002* 256 字节随机存储器
$27094240214067* 存储器元件


=== components/Constant16 ===

$85825068431072* 16 位常量
$61330657823382* 输出一个常数


=== levels/and_gate_3 ===

$14788981567936* 搭建一个有 3 路输入的与门。


=== components/DivMod16 ===

$42657221816637* 对两路输入作除法，输出商和余数
$22319923069746* 16 位除法器


=== components/MemoryProbeBit ===

$13846578075327* 可将自定义元件中存储的某个值显示在其表面，或链接到程序编辑器的监视槽上
$25103579211328* 存储器探针（1 位）


=== trans/level_byte_mux_text ===

$44961981616677*
[center]你的答案是 11 + 88 =  0
当前答案是 11 + 88  = 99[/center]


=== ui/verilog_format_options ===

$61009819785587* 无


=== components/DualPortRam ===

$13408945557666* 包含两套互不干扰的读取引脚的内存单元
$30400404542678* 双重加载内存


=== components/Switch64 ===

$80980797636768* 切换线路通断
$93223372486795* 64 位开关


=== misc/delay_overlay ===

$85430022417382* 显示延迟量


=== levels/push_pop2 ===

$10062117579269* 向你的电脑中添加一个栈
$14685569269160*
本关里，你需要为你的计算机添加一个栈，然后实现相应的指令，并自行编写一段程序以完成测试。
当输入为 0 时，你需要弹出（[color=#e49f44]pop[/color]）栈顶值，并将其发送到输出设备中。当输入不为 0 时，你需要将输入的值压入（[color=#e49f44]push[/color]）栈中。
$18561605111721* PUSH - 输入值 {input} 压栈
$59658696292688* POP - 弹出栈顶值 {value}


=== rpg/maps/overworld/crate ===

$37606760989079* 碎片
$78128919991233* 板条箱


=== trans/level_codes_description ===

$24678249110160* [center]为你的电路添加计算功能[/center]


=== trans/text_truth_table_left ===

$58617980046951*
[right]输入 1
输入 2
输出[/right]


=== dialogue/schematic_hub/load ===

$41294322771286* 载入
$44524092309946* 加载中…


=== rpg/maps/overworld/musli ===

$21621435534103* 这没道理呀。
$20939310165945*
为什么同样是这些燃料
进入了核心
却又原封不动地出来？


=== rpg/maps/overworld/purple_flower ===

$70367070546819* 看起来是朵花
$91230192040939*
这一定是咕丽叶
想要的花
$25076873142666* 粉色的花


=== trans/panel_segment_value ===

$97585846659258* [center]输入[/center]


=== trans/manual_delay ===

$78806697204524* 延迟量


=== trans/panel_constant_output ===

$14868502983738* 输出


=== rpg/maps/cave/door4 ===

$59392168282288* 地牢门


=== rpg/maps/unseen_fruit/gulgramush ===

$35182545479584*
不要破坏墙壁
坏机器人


=== trans/rpg_alloy_enter ===

$47375100278801* [center]要再试一次，请点击窗口左上角的复位键[/center]


=== components/Program8_1 ===

$11057354704814* 可编程存储部件
$12805545963716* 程序


=== components/Nor8 ===

$34517798310461* 对输入进行按位或非
$39421972053612* 8 位或非


=== levels/crude_awakening/next_level ===

$24027424800887* 下一关


=== trans/level_alu2_description ===

$37432913848309* [center]根据指令码，对输入的两个字节的数据进行按位或、或非、与非、与、加、减 6 种操作[/center]


=== trans/level_complete_stat_gate ===

$95192766583497* 门数量


=== levels/signed_negator ===

$10866019808027* 建议你在本关里使用有符号数值模式，该模式下最高位代表 -128。单击顶栏中的 “+255” 或 “FF” 字样切换数值模式。
$10400106910274*
本关里，输入将被视作有符号整数（最高位为 -128）。请设计电路，从输入端读取数值，并输出其相反数（改变符号）。
例如，4 对应的相反数是 -4，-9 对应的相反数是 9。


=== trans/level_circumference_subscript ===

$80632450818467* [center][color=#cccccc](假设 π ≈ 3)[/color][/center]


=== trans/panel_output_output_0 ===

$44355002441998* 输出 1


=== trans/overwrite_discard ===

$78824878529707* 取消


=== trans/options_missing ===

$22687523145097* 无记录


=== trans/level_xnor_RichTextLabel2 ===

$59451104901430*
[right][color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出[/right]


=== trans/options_language_disclaimer ===

$72959997258737* 语言设置将在游戏重启后生效。


=== ui/state_ui/title_screen/play ===

$66967233942803* 开始游戏


=== trans/level_ram_component_value_description ===

$53113984441582*
[right]测试
地址
操作
预期输出[/right]


=== trans/level_byte_less_description ===

$37336202055283* [center]判断第一个输入是否严格小于第二个。[/center]


=== components/Register16 ===

$16015376037787* 16 位寄存器
$71792123436163* 16 位存储单元


=== levels/Opcodes ===

$19693461238792* 将计数器增量设为 4
$38976231780455* 监视槽 {nr} 应链接到寄存器（或包含寄存器的自定义元件）上
$20916717363300* 监视槽 {nr} 应指向输出设备
$18189600217529* 实现指定操作码（OPCODE）对应的功能
$13450117997204* 往电路里加入一个计数器
$77044880242883* 监视槽 {nr} 应链接到计数器上
$13870568875751* 新建一份架构图，向图中添加一个有 4 路单字节输出的程序模块
$10303603301757*
实现下列操作码（OPCODE）的功能：
[code][color=#87a8c8]0 ADD（加法）
1 SUB（减法）
2 AND（按位与）
3 OR（按位或）
4 NOT（按位非）
5 XOR（按位异或）[/color][/code]

操作码 NOT 应忽略第二个输入操作数。
$17495651785164* 向电路图中添加 6 个寄存器


=== components/Mem Unit ===

$57670626909848* 1 位存储单元
$78616473760551* 1 位存储器


=== rpg/maps/prison/snake ===

$41424386577594* 蛇
$44205554907271* 嘶嘶嘎嘎
$36655099439467* 血


=== trans/panel_inputlevel_input ===

$27464111307888* 输入


=== misc/credit_box ===

$15872341864658*
由衷感谢：

[b]译者[/b]
{translators}

[b]早期版本测试人员[/b]
{beta_testers}

[b]字体[/b]
{font_work}

[b]原声带[/b]
 Adolfo Aaron Figueroa Bianchi

[b]开源软件[/b]
{software}

[b]资源[/b]
{assets}

欢迎帮助我们[url=https://paratranz.cn/projects/5404]改进翻译[/url]！


=== trans/level_flood_enter ===

$64481408588810* 按回车键显示水位


=== trans/panel_matrix_input1 ===

$94408716277517*
[right]启用 Y
颜色[/right]


=== trans/options_pan_left ===

$78515694621006* 视图左移


=== rpg/maps/prison/control_panel_release ===

$78007210535349* 控制面板


=== trans/panel_hdd_size2 ===

$82587023815880* 容量（字节）：


=== trans/panel_splitter8_input ===

$90934251511339* [right]输入[/right]


=== rpg/maps/unseen_fruit/Gulgramush JR ===

$21404721941060* 你知道地球人用脸吃饭吗？


=== misc/lab_toggle ===

$16432178820878* 实验室模式


=== components/Program4 ===

$27522667367787* 程序
$45650720555565* 可编程存储部件


=== trans/options_controls ===

$18297012748869* 控制选项


=== levels/Counter ===

$17701404772563* 计数器加 1
$17940006660359* 计数器步进
$17263901743088*
搭建一个计数器，每个时钟刻，其中存储的数值都会自动加 1。

此外，计数器还应有一个擦写功能，允许使用输入的数值覆盖计数器内存储的数值。

本关有两个输入端：一个 1 位输入，一个单字节（8 位）输入。

1 位的输入端用于切换步进模式和擦写模式，单字节的输入端则用于指定要写入的数值。
$68874699768861* 改写为 {value}
$17883663978196* 擦写
$19407121413983* 操作
$10555159894041*
计数是一项昆虫也具备的基本能力。有了计数能力，生物就有了进行比较和算术的能力。然后在不知不觉间，猴子们也就能学会制造电脑了。

搭建一个元件，使其每一刻输出的数值都会自动增长。


=== components/Constant32 ===

$39402227599142* 输出一个常数
$30896164786171* 32 位常量


=== trans/manual_text_ram ===

$10969790213397*
本游戏的电路仿真器为你提供了几种不同类型的内存（RAM），它们在不同的方面进行了不同的取舍权衡。这和现实生活中不同类型的内存是类似的。

[b]内存（RAM）[/b]
内存元件可以写入大量的数据，但会给电路增加很高的延迟。

[b]高速内存（Fast RAM）[/b]
高速内存的延迟很低，但写入每个字节都会产生很大的逻辑门开销。

[b]延迟内存（Latency RAM）[/b]
普通内存使得电路在每个时钟刻都有非常高的延迟，而使用延迟内存，电路不需要在每个时钟刻都等待内存延迟，而是仅仅在读取或写入的时候才等待内存延迟。读取和写入需要的时间取决于每个时钟刻的长度。例如，如果我们的电路有 100 个单位的延迟，而写入操作大约产生 1000 个单位的延迟，那么一次写入操作将需要 10 个时钟刻才能完成。

使用流水线架构的 CPU 常常使用延迟内存作为主存储器，但同时也使用少量的快速内存作为缓存。由于一定时间内对存储器的访问操作通常只发生在某个局部上（例如遍历一个数组的所有元素），所以如果我们在进行访存操作时，能够一并读取出同一个局部的所有数值并将其保存在高速缓存中，我们就可以显著提高某些程序的运行效率。

要想在电路中添加延迟内存，最简单的方法就是在每次进行读写操作时暂停整个架构的运行，直到操作完成为止。在此基础上可以做一点简单的优化：你不需要在每次写入内存的时候都暂停系统运行，只需在读取数据的时候这么做就行。

[b]双口内存/双重加载内存（Dual Load RAM）[/b]
有时，将部分逻辑分离为一个独立的处理单元会带来很多好处。该单元可能需要负责控制一个显示设备或一个网络设备。在这些情况下，独立单元往往需要不断地对内存执行读写操作，而这个单元之外，负责处理内部业务逻辑的电路可能只需要偶尔进行访存操作。使用双口内存，你可以允许电路的不同部分互不干扰地进行读取操作。这样一来，你就无需把精力花在安排不同的设备的访存次序上了。


=== component_panels/sprite_display_select_button ===

$18632189666863* 选择文件


=== trans/map_locked ===

$95146987030704* 未解锁


=== levels/circular_dependency_check ===

$25155953943906* 正确！
$32314337981189* 核对
$73467991035922* 错了！
$22446480186064* 构造一个包含至少 2 个元件的循环依赖结构


=== levels/decoder ===


#  Short because it will become the name of a custom component
$62618958406279* DEC
$16133643476631* 你之前在“寄存器之间”一关中建立的电路可以在寄存器之间复制数值，而在“算术引擎”一关中建立的电路可以对 2 个输入做不同的算术运算。但在后续的关卡中你将需要在同一个电路中同时进行这两种操作。要做到这一点，你需要建立一个“解码器”。它能根据指令中我们尚未使用的那两位数值，来决定我们的计算机处于何种模式。
$18435544383511*
计算指令（CALCULATE）
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$18198768092383* COPY
$18945946395447*
为了区分 4 种不同的[INSTRUCTIONS]，最高的两个位将被用来确定我们处于哪种模式，如下所示：
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Immediate（立即数模式）
[OFF] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Calculate（计算模式）
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Copy（复制模式）
[ON] [ON] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY] Condition（条件跳转模式）

这里的 [ANY] 意味着既可以是 [ON] 也可以是 [OFF]。

由输入确定我们所处的模式，然后将相应的一路输出设为 [ON]。
$16785126425267* CALCULATION
$15440615199508* CONDITION
$15105859227432*
复制指令（COPY）
[ON] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$11382827588408*
条件跳转指令（CONDITION）
[ON] [ON] [OFF] [OFF] [OFF] [ANY] [ANY] [ANY]
$82074370773365* 指令
$12976424717611*
立即数指令（IMMEDIATE）
[OFF] [OFF] [ANY] [ANY] [ANY] [ANY] [ANY] [ANY]
$12532951884542* IMMEDIATE
$10169248860836* 解码指令


=== levels/call_ret/no ===

$90567812500955* 否
$82611295916141* 你是诚实的，我们对你的看法有所改观。


=== trans/level_signed_negator_description ===

$87777776285772* [center]反转数字的符号[/center]


=== rpg/maps/overworld/chef (2) ===

$60791074149079* 主厨
$43137217122501* 你需要帮助


=== trans/options_effects_volume ===

$24145565754506* 音效音量


=== trans/panel_maker64_input ===

$67636019772385*
[right]第 1 字节
第 2 字节
第 3 字节
第 4 字节
第 5 字节
第 6 字节
第 7 字节
第 8 字节[/right]


=== trans/level_compute_xor_description ===

$61886892927185* 对两路输入的每一位逐对执行异或（XOR）运算


=== main_scripts/overture_level ===

$82949244692745* Calculate
$11338791453100* 动态
$27259865408750* 计数器在下一刻的数值为 {next}，正确数值应为 {expected}
$95030012922256* 仅当从输入中复制数值时，才应该启用输入元件
$92808834805287* 从输入端复制到输出端
$12873109232054* 预期输出 {expected}，当前输出 {got}

#  Keep as short as possible as it has to fit on a component. 2 characters preferably, but 3 if you must
$85842797287714* R4

#  Keep as short as possible as it has to fit on a component. 2 characters preferably, but 3 if you must
$39748815905832* R2

#  Keep as short as possible as it has to fit on a component. 2 characters preferably, but 3 if you must
$81103754316448* IN

#  "cond" is for condition, this label has to be 4 letters or less as it has to fit on a component
$94982725578534* COND
$93579176707338* 从输入端（{input_val}）复制到 REG {reg}

#  Keep as short as possible as it has to fit on a component. 2 characters preferably, but 3 if you must
$49076331369118* R5
$95699170830383* 将立即数 {nr} 写入到 REG 0
$90667501138629* 若 REG 3 ≥ 0，将计数器置为 {val}
$15507583089532* REG {nr} 的值应该为 {value}
$78673238418574* 你的电路缺少一个计数器元件，你可以在“8 位”菜单中找到该组件
$76213462280109* 若 REG 3 > 0，将计数器置为 {val}
$65651227755356* 计数器在下一刻的数值为 {actual}，正确数值应为 {expected}
$56098077111355* 若 REG 3 ≠ 0，将计数器置为 {val}
$36131297419794* 你不应该擦写计数器中的值
$19724825417529* 从 REG {n1} 复制到 REG {n2}
$47188699762650* 输出元件未启用
$75122220982708* 从 REG {n1} 复制到输出端

#  Keep as short as possible as it has to fit on a component. 2 characters preferably, but 3 if you must
$28690475492473* OUT
$44533909869936*
算术元件应该以 REG 1 和 REG 2 中的数值作为输入，其结果应该写入 REG 3。
似乎你使用的是 REG 0、REG 1 和 REG 2。
$28026304798371* 仅当将数据复制到输出时，才应该启用输出元件
$51029568177086* 若 REG 3 < 0，将计数器置为 {val}
$79405336618718* 将立即数 {nr} 写入到 REG 0
$85260864781281* 输入元件未启用

#  Keep as short as possible as it has to fit on a component. 2 characters preferably, but 3 if you must
$73538301913919* R0

#  Keep as short as possible as it has to fit on a component. 2 characters preferably, but 3 if you must
$80997977734042* R3
$96569633331621* 将数值 {value} 写入 REG 0

#  Keep as short as possible as it has to fit on a component. 2 characters preferably, but 3 if you must
$37653426314061* R1
$51099912089198* 将计数器重置为 {val}
$83829200305236* 预期输出 {expected}，当前输出 {got}
$50124579293905* 若 REG 3 ≤ 0，将计数器置为 {val}
$16914143080303* Copy
$23384670264323* 若 REG 3 = 0，将计数器置为 {val}
$59042824277105* Immediate


=== levels/Further Delayed Lines ===

$17366913897135* 搭建一个电路，使输出与输入相同，但延迟 2 刻。
$60989431641221*
本关引入了延迟线元件。它接受一个输入后，会延迟 1 刻将其输出。

[img]dialogue/delay_buffer_zh_CN.png[/img]


=== trans/nand_Label2 ===

$60885816586685* 输出


=== levels/negative_numbers ===

$17231048881956* 要知道事物之间的差异，你需要减法。而要得到减法，首先你需要负数。
$13872783467999* 有符号二进制的 {number} 如何表示?
$49993940138672*
本关里，我们将引入“补码”的概念，这是二进制系统里负数最常用的表示方法。
	
在补码表示法中，最高位的数字是负数。对于单字节数据而言，这意味着最高位（第 8 位）代表的数值从 128 变成了 -128。

要通过本关，你的成绩至少需要达到 3 级。

（单击[color=#e63e5b][url=accessibility_mode]此处[/url][/color]启用不计时的辅助模式）
$97450409600317*
[b]要点总结：[/b]

1. 要在正数和负数之间切换，你需要将所有的位翻转，然后加 1。
2. 如果最高位为 [ON]，那么数值一定是负数。
3. 你先前搭建的加法器可以直接用于有符号的整数。
4. 每个数字（特别是 0）的表示方法是唯一的。
$37471385247951* 干得漂亮，你的成绩达到第 {current_level} 级了。


=== levels/NAND Gate ===

$17420270098223* 本关中，你将了解到与非门（NAND）是如何运作的。请在这一关尽量[color=#dd6576]牢记[/color]与非门的特性，否则你接下来会很容易卡关！
$11034378482152* 正确！你成功解锁了与非门（NAND）。利用这个元件，你就能造出电脑里所有的东西了！
$18270083417453* 核对
$19208664264770*
[b]操作指南[/b]
点击下方图表中最后一行的灰色按钮。
$17923274216766* 我们因此初步认定你大概不是一种植物。
$14777350869870* 你在上个测试中发挥得不错！
$17994568832660*
[b]操作指南[/b]
电路中间的与非门（NAND）会改变输出信号。
点击左侧的按钮调整输入，观察输出，并将结果填在下方。


=== components/Input 2 ===

$86870364449392* 输入


=== components/Bit Compressor ===

$74338505460996* 将八根 1 位线合并为一根 8 位线
$98747779812970* 8 位集线器


=== trans/options_copy ===

$55679445263875* 复制


=== trans/options_pan_down ===

$93140495547084* 视图下移


=== components/Mux64 ===

$14050204031082* 二选一选通器
$66892629981737* 64 位数据选择器


=== trans/manual_hard_disk ===

$45865138134248* 硬盘


=== components/NOR ===

$27510848535619*
仅两路输入均为 [OFF] 时输出 [ON]
[table=5]
[cell]输入 1[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]输入 2[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]输出[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][OFF][/cell]
[/table]
$83375115196253* 或非门


=== levels/hex_racer ===

$92057009138253* 十六进制的 {number} 如何表示？
$16009852370452*
当数字有很多位时，二进制数会变得难以阅读，十六进制则会显得更加简短。十六进制下，每个字符对应二进制数中的 4 个数位：
[code]
0 [OFF][OFF][OFF][OFF]
1 [OFF][OFF][OFF][ON]
2 [OFF][OFF][ON][OFF]
3 [OFF][OFF][ON][ON]
4 [OFF][ON][OFF][OFF]
5 [OFF][ON][OFF][ON]
6 [OFF][ON][ON][OFF]
7 [OFF][ON][ON][ON]
8 [ON][OFF][OFF][OFF]
9 [ON][OFF][OFF][ON]
A [ON][OFF][ON][OFF]
B [ON][OFF][ON][ON]
C [ON][ON][OFF][OFF]
D [ON][ON][OFF][ON]
E [ON][ON][ON][OFF]
F [ON][ON][ON][ON]
[/code]

以 16 位二进制数为例，可以看出十六进制要简明得多：
[code]
二进制：     1111111111111111
十进制：     65535
十六进制：   FFFF
[/code]

如果一个二进制数漏写了一位、或十进制数差了 1，我们是很难发现这种错误的。但在十六进制表示下，发现这些错误就容易得多（前提是你已经习惯了这种表示方式）。
$84691609525475* 这关是我第二喜欢的消遣小游戏。在规定时间里把十进制数转成十六进制数。
$87016829502381* 干得漂亮，你的成绩达到第 {current_level} 级了。
$43463538043782*
单击切换窗口下方的数位开关，使被点亮的数字总和等于题目中给出的十六进制数。

要完成本关，你至少需要连续通过 3 级。

（单击[color=#e63e5b][url=accessibility_mode]此处[/url][/color]启用不计时的辅助模式）


=== rpg/maps/unseen_fruit/Sign ===

$96190557871470* 告示牌
$11494676474259*
上面写着：别光站在这儿看告示牌，机器人！
赶紧检查水果去


=== trans/level_full_adder_RichTextLabel2 ===

$25766177620842*
[right][color=#e49f44]输入 1
输入 2
输入 3[/color]
预期总和
预期进位
当前总和
当前进位[/right]


=== components/Ror8 ===

$10802217509530* 对输入执行按位循环右移
$70999134800536* 8 位循环右移器


=== trans/options_general_tps ===

$53724631742096* 显示每秒运行的时钟刻数量


=== trans/map_arithmetic ===

$51337598329530* 算术运算


=== components/NAND ===

$71130919681688* 与非门
$12903183841172*
仅两路输入均为 [ON] 时输出 [OFF]
[table=5]
[cell]输入 1[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]输入 2[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]输出[/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]


=== trans/rotate ===

$88236351843942* 旋转


=== levels/Dancing Machine ===

$14975070588197*
我们都喜欢机器人在舞池中的动作。因此我们希望他能带领我们的舞蹈队。 

唯一的问题是如何让他想出原创的舞蹈序列。你或许会问，如何从决定性的逻辑中诞生出创造性的力量？

答案是通过伪随机数生成器。
$15955150920362*
在这一关中，你只得到一个输入，我们称之为初始种子（seed）。通过以下步骤由该种子产生一个伪随机数。

在下面的算法中，“shl 1”表示左移一次，“shl 2”表示左移两次，“shr 1”表示右移一次。

[b]8 位异或移位随机数生成：[/b][code][color=#87a8c8]
temp1     = seed  xor (seed  shr 1)
temp2     = temp1 xor (temp1 shl 1)
next_seed = temp2 xor (temp2 shr 2)
[/color][/code]
然后输出 next_seed mod 4 来移动机器人。接下来使用（取模运算之前的） next_seed 作为新的种子，产生跳舞序列中的下一个随机数，如此往复。

（注意，初始种子永远不会是 0）


=== trans/panel_fileloader_enable ===

$80528055112236* [center]启用[/center]


=== trans/level_dance_description ===

$29803992718733* 利用伪随机数，生成机器舞步


=== misc/program_edit_signals ===

$98772447663910* 编辑监视态


=== main_scripts/levels ===

$15232844525838*
设计一个与给定的真值表完全匹配的电路。
	
[tip]双击一个组件，即可将它和与其连接的导线一并移动。[/tip]
$64510812504271*
你的电路图里出现了按说无法在这一关里获得的元件。
因此，我们不会保存本次的分数。

#  Level type for the level complete menu
$58769207148712* 电路元件关卡

#  Level type for the level complete menu
$90134890578411* 普通关卡
$68327708695625*
[b]解锁手册词条[/b]

 词条：[color=#68d277]{page}[/color]

#  Level type for the level complete menu
$69219742310717* 计算机架构关卡


=== trans/level_decodre_RichTextLabel2 ===

$40723962298647*
[right][color=#e49f44]输入 1
输入 2
输入 3[/color]
期望激活线路
当前激活线路[/right]


=== trans/manual_bytes ===

$46223559629673* 字节


=== component_panels/Counter ===

$42544828625264* 增量为 0 时计数器无法工作（仅具有寄存功能）
$57936010210151* 计数器单步增量：{amount}


=== trans/panel_ram8_output ===

$90649838965927* 输出


=== trans/panel_cond_input_2 ===

$82398835019064* 第2位：


=== trans/level_complete_ide ===

$56719825235196*
[b]汇编代码编辑器[/b]
[color=#cccccc][i]为代码设定别名，并在文本编辑器中使用它们[/i][/color]


=== trans/and_gate_3_RichTextLabel2 ===

$52008707927408*
[right][color=#e49f44]输入 1
输入 2
输入 3[/color]
预期输出
当前输出[/right]


=== trans/panel_nand ===

$51470292662088*
[right]输入 1
输入 2
输出[/right]


=== rpg/maps/overworld/captain_grog ===

$54304087865803* 全舰进入深海状态，前进四准备！
$28819210888759* 舰长 Grog


=== rpg/maps/overworld/hat_man ===

$66365217340789* 帽子商


=== trans/options_level ===

$64744152268407* 关卡


=== components/LessU32 ===

$72614358420262* 32 位小于比较器（无符号）
$55380524073095* 判断输入 1 是否严格小于输入 2


=== trans/panel_mul_input ===

$52124868557994*
[right]输入 1
输入 2[/right]


=== components/Output64z ===

$35798118634001* 64 位三态输出
$42506906257154* 只在开关引脚为 [ON] 时输出，否则不输出


=== ui/toggles/race_condition ===

$75558678297830* 循环依赖


=== trans/assembly_editor_header ===

$14116831487331* 汇编代码编辑器


=== trans/options_paste ===

$52159578521318* 粘贴


=== trans/hub_stats ===

$30942143953871* 用户


=== trans/manual_text_terminology ===


# DateCustoms
$99266452352883*
[b]指令（Instruction）[/b]
使计算机执行某个特定动作的一个或多个字节的信息。

[b]操作码（Opcode）[/b]
指令的一部分，它决定了要进行何种操作（如 ADD 或 AND）。

[b]内存地址（Memory Address）[/b]
用以指定内存中某个特定位置的编号（通常存放在寄存器中）。此编号指定了指令应该从何处读取数据以及将数据写入到何处。

[b]跳转（Jump）[/b]
改写程序计数器的值，该操作将改变下一条指令的加载位置。


=== trans/manual_text_truth ===

$16559670174521*
游戏中经常会用到电路输入和输出的对应关系表。这种表一般被称作真值表。








现实的数字电路设计中，“输入”和“输出”往往会被具体的变量名称代替，以便进行代数运算；此外，和使用不同颜色相比，更常见的还是用 0/1 、F/T 或真/假等字符来代表不同的输出状态。


=== trans/level_double_buffer_RichTextLabel3 ===

$27208335953837*
[right]输入
预期输出
当前输出[/right]


=== levels/Conditionals ===

$10794262854382*
在你的电路中加入 if 语句跳转功能。在 if 语句中，你需要判断输入的 2 个参数是否满足要求，如果结果为真，就对计数器的数值进行擦写。

在之前的指令中，4 个字节分别代表：
[code][color=#87a8c8]操作码（OPCODE）、参数 1（ARGUMENT_1）、参数 2（ARGUMENT_2）、结果地址（RESULT）[/color][/code]

而对于 if 语句，4 个字节分别代表：
[code][color=#87a8c8]操作码（OPCODE）、参数 1（ARGUMENT_1）、参数 2（ARGUMENT_2）、跳转地址（JUMP_ADDRESS）[/color][/code]

你需要在之前的操作码的基础上，添加并实现下列指令：
[code][color=#87a8c8]32 IF_EQUAL（等于）
33 IF_NOT_EQUAL（不等于）
34 IF_LESS（小于）
35 IF_LESS_OR_EQUAL（小于等于）
36 IF_GREATER（大于）
37 IF_GREATER_OR_EQUAL（大于等于）[/color][/code]

比较时请将输入视作无符号整数。

操作码的名字和它们的功能应该是一致的。例如，如果 0 号寄存器的值小于 1 号寄存器的值，下面的指令就会使程序跳转到第 16 字节处：
[code][color=#87a8c8]IF_LESS REG0 REG1 16[/color][/code]
$18542005958715* 将计数器增量设为 4
$17133561664335* 恭喜，你已经实现了 [color=#e49f44]LEG[/color] 计算机的全部功能！
$14973719570693* 往电路里加入一个计数器
$12920514303805* 向电路图中添加 6 个寄存器
$14309211963063* 新建一份架构图，向图中添加一个有 4 路单字节输出的程序模块
$16826220977157*
 [color=#b72d41][b]提醒：[/b][/color]
复制（COPY）其实就是第二个参数为 0 的加法（ADD）。
$14690660047411* 实现条件跳转操作码
$30132649789584* 监视槽 {number} 应指向输出设备
$18994998239232* 我将逐步向你展示一些可能的升级操作，直到你实现函数调用功能为止。但从今往后，一切实现细节由你自己决定，我不会再要求你应该使用什么操作码，也不会给你施加其他诸如此类的限制。
$12034111753799* 监视槽 {number} 应链接到计数器上
$36561706158040* 监视槽 {nr} 应链接到寄存器（或包含寄存器的自定义元件）上


=== misc/multi_select ===

$85147529532131* 多选（快捷键：SHIFT+左键拖动）


=== components/Splitter16 ===

$92674917729864* 16 位分线器
$28271182652741* 将一根 16 位线拆分为两根 8 位线


=== trans/manual_text_universal_gates ===

$37735744928195*
游戏的前几关已经说明，所有的逻辑门都可以用与非门（NAND）搭建出来。可以证明，或非门（NOR）也具有同样的能力。这两种逻辑门被称作通用逻辑门（universal gates），你可以只用这两种逻辑门中的一种来构造任何数字电路，并实现电脑的所有逻辑功能。历史上，为阿波罗飞船进行制导计算的电脑里，数字电路就是全部由或非门制成的。这台电脑是 20 世纪 60 年代的产物，只有区区 4KB 内存和 32KB 外存空间，不过即便如此，它也成功将宇航员送上了月球。

现代的电脑一般会用到不止一种逻辑门，不过一般来讲厂家还是会尽量多用与非门，少用或非门。这是因为尽管两种逻辑门在逻辑功能上相同，但在实际的芯片产品上，与非门占据的面积却更小，延迟也更少（响应速度更快）。


=== rpg/maps/overworld/slime ===

$15692058001120* 史莱姆
$69726620971060* 收集到了所需的所有粘液球
$87592944464187* 收集了粘液球, 还需要 {nr} 个
$44317276399194* 粘液球


=== trans/panel_segment_info ===

$64695289448271* 8 位输入中的每一位分别对应数码管上的一个部位


=== trans/panel_keyboard_event ===

$67549215280299* 按键事件


=== trans/inputlevel_enable ===

$28654406516589* [center]禁用 / 启用[/center]


=== trans/levels_byte_or_description ===

$68379799788575* [center]对两路输入的每一位逐对执行逻辑或运算[/center]


=== levels/counting_signals ===

$10724914203078*
本关里你要实现的电路是一个二进制计数器，它的三个输出引脚分别对应 1、2、4 三个二进制数位。
这个计数器的功能是计算四路输入里有多少路处于 [ON]，并将结果转换成二进制，发送到输出端的三个引脚上。

如遇困难，可以参考[color=#e63e5b][url=counting_signals]这个提示[/url][/color]。

[i][tip]此关卡的解法不很简洁，你需要用到比前几关里更多的元件。[/tip][/i]
$10881918807029*
[color=#b72d41][b]提示：[/b][/color] 
用纸笔来帮助思考并不可笑。


=== misc/button_next ===

$80746616574054* 下一刻（快捷键：F5）


=== ui/toggles/level_map ===

$71951682957395* 浏览关卡


=== components/DivMod64 ===

$80284847781948* 64 位除法器
$71663353206665* 对两路输入作除法，输出商和余数


=== levels/saving_bytes ===

$10633476398156*
搭建一个可以[SAVE]或[LOAD]一个字节的电路。

当输入的第一个信号位为 [ON] 时，[LOAD]存储器中的值，并将其发送到输出端。
当输入的第二个信号位为 [ON] 时，向存储器中[SAVE]数值。

输出端下方有一个“启用”引脚，请仅在[LOAD]时向该引脚发送 [ON] 来启用它。
$15510981129613* 读取
$13502950630653*
[color=#ff9800]无
0
0[/color]
$19109563882664* 不读取
$16372198430230* 写入
$11467279617581* 写入
$15498440508450* 无操作
$10080722944246* 不写入
$18873598212433* 读取
$15582618410991* 读取并写入


=== levels/byte_constant ===

$12641789008694* 搭建一个电路，使之始终输出 164。


=== trans/panel_ram_fast_input ===

$80778301064570*
[right]读取
写入
地址
待写入数值
待写入数值
待写入数值
待写入数值[/right]


=== levels/odd_ticks ===

$18510295620397* 请设计电路，在偶数刻输出 [OFF] ，奇数刻输出 [ON] 。
$16987046679863* 上一关里，你已经知道了我们不允许电路中存在循环依赖。现在你需要掌握一种例外情况。
$16037516781370*
游戏中方形引脚的输入不会影响同一刻的输出值，因此，方形引脚不会造成循环依赖。
	
	[img]dialogue/delay_buffer_zh_CN.png[/img]
$17588119878416*
新元件“延迟线”的输入端可以与自身的输出端直接相连。这是因为这个元件当前的输入信号直到下一个时钟刻才会对电路其它部分产生影响。
	
[img]dialogue/delay_buffer_zh_CN.png[/img]


=== components/Adder Simple ===

$33973952772642* 8 位加法器
$98429814030509* 对两路输入求和


=== trans/panel_ram8_input ===

$54796685972031*
[right]读取
写入
地址
待写入数值[/right]


=== trans/level_complete_delay ===

$73470840319057*
[b]延迟[/b]
[color=#cccccc][i]现在你可以查看元件和线路的延迟量了。[/i][/color]


=== trans/panel_ram_fast_output ===

$44175594625487*
输出 1
输出 2
输出 3
输出 4


=== misc/select_color ===

$97461374731210* 导线颜色


=== trans/level_saving_gracefully_RichTextLabel3 ===

$74117520663650*
[right][color=#e49f44]写入
待写入的值[/color]
预期输出
当前输出[/right]


=== trans/manual_text_circular_dependency ===

$29050562435902*
当元件的输入随自身的输出而变化时，循环依赖就出现了。

[center][img]res://dialogue/circular_dependency.png[/img][/center]

此游戏的电路仿真器不允许循环依赖的存在。当检测到循环依赖时，程序会报错。

但一种情况例外——方形引脚不会影响同一刻内的元件输出，所以将元件的输出连接到自身的方形输入引脚上不会造成循环依赖。

[center][img]res://dialogue/delay_buffer_zh_CN.png[/img][/center]


=== trans/panel_splitter16_output ===

$19314358335345*
第 1 字节
第 2 字节


=== rpg/maps/overworld/door3 ===

$62992379521216* 门
$12075276554344* 门把手坏了


=== trans/level_alu2_text ===

$58359423026017*
[right]操作码
[color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出
[/right]


=== trans/options_explicit_clock ===

$90384542658266* 允许使用时钟电平代替时钟刻


=== levels/push_pop ===

$78804623186243* 输出
$49526452710191* 不弹栈
$58050047963238* 待压栈数值
$30926395960020* 压栈
$19245209470436* 设计电路，实现栈的功能

#  Short because it will become the name of a custom component
$84236889840605* 栈
$12227209887733*
每一时钟刻，输入端都会接收到压栈（PUSH）或弹栈（POP）的信号之一（也可能两个信号都没有接收到）。如果收到压栈的信号，请将输入的数值存储在栈的顶部。而当收到弹栈的信号时，请移除栈顶数值，并将该值发送到输出端。

该关卡的输出组件上有一个“启用”引脚，请仅在弹栈（POP）时向该引脚发送 [ON] 来启用它。
$85171087236638* 启用
$15662660252584* 不执行任何操作
$23726790986805* 弹栈
$62469306234943* 不压栈
$46948857059388* 从栈顶弹出 {value}
$65188797398656* 将 {value} 压入栈顶
$18761197388580* 为了削减开支，我们决定改变服务窗口的排队制度，以减少来访的人数。我们将用“先来后服务”的模式代替原先的“先来先服务”模式。试想一摞叠得高高的文件，公民们只能把提交的文件放到最上面（称[color=#e49f44]压栈[/color]，即[color=#e49f44]PUSH[/color]），而办事的员工也从最上面拿走文件开始处理（称[color=#e49f44]弹栈[/color]，即[color=#e49f44]POP[/color]）。这种数据结构的名称叫[color=#e49f44]栈[/color]（[color=#e49f44]stack[/color]），我们希望你能够在硬件层面实现它。


=== levels/The Product of Nibbles ===

$14957949958941* 你刚才已经设计出了两路 4 位输入的乘法装置。我们让我们的实习生免费把它扩展成了 8 位乘法器。
$14622683750375* 第 2 位
$17331397914567* 第 1 位
$19136817138607* [center]将输入的两个 4 位数字相乘[/center]
$13232094477834* 第 3 位
$13549246864135* 第 0 位
$15857218442751* 第 1 位
$14533861483435* 将两个 4 位数字相乘，便可以得到最多 8 位的乘积。设计一个电路，实现此乘法功能。
$10430040077737* 第 3 位
$10274387271390* 第 0 位
$16301538038805* 第 2 位
$83694551809785* 当前计算：{num1} 乘 {num2}


=== trans/panel_matrix_column_major ===

$90704227545058* 列优先模式


=== trans/panel_counter16_input ===

$87154643308632*
[right]步进/擦写模式
待写入的值[/right]


=== rpg/maps/spacial_invasion/door ===

$59863326177819* 这扇门锁上了
$13853333722323* 门


=== ui/toggles/level_log2 ===

$91515053618360* 手册


=== trans/panel_not ===

$33240384048149*
[right]输入
输出[/right]


=== main_scripts/functions ===

$11467644007149* 计数器 {nr}
$35675567872962* 增量为 0 的计数器没有任何功能
$73560327420927*
该存档是在一个较低的游戏版本中创建的，当前版本已不再兼容。
请新建一份电路图，并重新设计电路。
$99285446909923* 要通过本关，你必须使用“关卡输出”元件
$41936481068702* 计数器
$72465734060414* 发生短路（下列输出被短接：{values}）
$10533010562232* 总延迟：{delay}
$10098517717617* 测试：{nr} / {total}
$83854326413007* 由于自定义元件“{name}”的尺寸已发生了变化，无法在原处安放，因此该元件已被从电路图上移除。
$29225283986051* 要通过本关，你必须使用“关卡输入”元件
$95056157627313* 要通过本关，你必须使用“关卡输入”元件
$87591753278764* {nr} 号寄存器
$39587966698723* 元件“{custom_component}”内部发生短路

#  Right hand side menu
$29169064199243* 输出 {nr}
$12249248261034* 要通过本关，你必须使用“关卡输出”元件
$13327741293223* 输入 {nr}
$32508339206292* 门数量：{gate}
$42012207828907* 寄存器


=== misc/view_solution_button ===

$59351520832720* 确认


=== levels/or_gate_3 ===

$15448906128695* 搭建一个有 3 路输入的或门。


=== trans/map_complete ===

$81337533438394* 已通过


=== trans/delay_score ===

$29032982097458* 总延迟：


=== trans/panel_mul_output ===

$55253255963402*
乘积（低位）
乘积（高位）


=== trans/panels_config_delay_delay ===

$52499013005170* [right]延迟量[/right]


=== rpg/maps/unseen_fruit/Lolbert ===

$77789556089413*
地球的水果要比我们这
日常供应的炖菜要好吃得多


=== trans/binary_racer_count_down2 ===

$23959994711260* 准备好了吗？


=== trans/level_capitalize_input ===

$23002150617591* Input


=== levels/Storage cracker ===

$11910674853271*
储藏室的保险门坏了，我们的老清洁工被锁在了里面。

这扇门总是无缘无故地改变密码，因此我们需要一个可以随时恢复密码的程序。
$17462419719036*
找到密码的最简单方法是尝试所有的组合，直到你找到正确的密码。
另外，当你猜测的数值过高时，这个坏掉的锁会发出奇怪的哔哔声。利用这一点，你或许可以找到更高效的解法。
$11183892008673* 当你输出正确的密码时，你就通过了这一关；输出任何错误数值都不会导致你输掉本关。另外，如果你的猜测值大于正确答案，输入将被设为 1；否则输入为 0。


=== trans/level_alu1_text ===

$53254733455389*
[right]操作码
[color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出
[/right]


=== components/Output16 ===

$48008022162230* 16 位输出


=== rpg/maps/overworld/book_shelf ===

$29366577532389* 书架
$26595142082551* 精致的书架


=== components/Input 3 ===

$70689623552857* 输入


=== trans/options_cut ===

$88238310953306* 剪切


=== trans/manual_text_top_truth ===

$83283949590490* 与门（AND）


=== rpg/maps/overworld/gruliette ===

$83120363112787* 噢，你好，帅哥
$61022705156373*
天啊，我终于
摆脱了这个任务
$84856635901648* 啊啊啊，我的心融化了！
$16008092188500* Gruliette
$58406047748371*
除非他可以给我
带一朵粉色的花
$68101445990611* 粉色的花在这儿
$18919563572338*
你想和多密欧
约会吗？
$68725679456014*
*亲* 替我把这个吻
带给多密欧
$73977053028689* 噢，你好，帅哥
$50949692384224* 我的耳朵受伤了
$35813418867082* 这真不凑巧


=== trans/panel_network_next_event ===

$80836714383432* 在一个 [color=#39aa49]事件类型[/color]


=== trans/panel_fileloader_description ===

$72892007399429*
文件加载器以每次 8 个字节的吞吐量输出一个文件的内容。

地址为 64 位，其中最高位（0xFFFFFFFFFFFFFFFF）有特殊用途，它以字节为单位输出文件的长度。


=== trans/and_gate_RichTextLabel2 ===

$98472849629373*
[right][color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出[/right]


=== components/Clock ===

$29674337035619* 在电路中放置时钟电平元件后，每个抽象时钟刻将被拆分成两部分。电路模拟将会改为一次前进半刻，同时时钟电平元件会输出这半刻中的时钟信号：前半刻为低电平 [OFF]，后半刻则为高电平 [ON]。电路中所有存储元件将会在前半刻进行读取，在后半刻进行写入。
$73207565196164* 时钟电平


=== components/1_decoder ===

$26685462633615* 在 2 路输出中选择一路
$98250587600120* 1 位解码器


=== trans/panel_input_left ===

$91063734228931* 左


=== components/XOR ===

$86856280609387*
当两路输入不同时为 [ON]
[table=5]
[cell]输入 1[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]输入 2[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]输出[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][OFF][/cell]
[/table]
$54832952840086* 异或门


=== trans/options_undo ===

$58334563411624* 撤销


=== misc/factory ===

$53123649343022* 元件工坊


=== trans/tps_label ===


#  Stands for Ticks Per Second (an option in the menu)
$25685496576554* 每秒刻数：


=== trans/manual_ram ===

$61854681801183* 内存


=== trans/levels_computing_input ===

$23173159754705*
指令
输入


=== trans/manual_header ===

$10757271456963* 手册词条


=== components/Ror16 ===

$13970397213910* 对输入执行按位循环右移
$90115282457191* 16 位循环右移器


=== rpg/maps/overworld/thing ===

$97983135944004* 某物
$65301573705048* 我什么都非得看一眼吗？ 


=== misc/opcode_name ===

$15090156481094* 命名


=== misc/level_gate_unlocks_unknown ===


#  This is a tooltip for levels on the level map, before something has been unlocked.
$76731326010721* 解锁神秘物体


=== trans/map_cpu_architecture ===

$95559333192525* 处理器架构


=== trans/panels_sound_description ===

$65379881141228*
[b][color=#e49f44]命令类型（Command type）[/color][/b]
[code]0[/code] No request（无操作）
[code]1[/code] [color=#e49f44]Play[/color]（播放）
[code]2[/code] [color=#e49f44]Reset and play[/color]（重置并播放）
[code]3[/code] [color=#e49f44]Stop[/color]（停止播放）


=== trans/levels_negative_header ===

$82195103144851* [center]要求[/center]


=== components/LevelOutput1 ===

$12242923444593* 输出


=== levels/byte_adder ===

$16888130664370*
如果结果超出了 8 位所能容纳的范围，则将进位设为 [ON]（你可以把它看作是第 9 位）。

除了两个数字外，还有一个 1 位的输入，用于接收来自其它地方的进位，它能帮助我们将多个加法器串联起来。如果其值为 [OFF]，你可以把它视作 0，如果其值为 [ON]，你可以把它视作 1 。

如果你卡关了，请参考[color=#e63e5b][url=byte_adder]这个提示[/url][/color]。
$18732877690173* 将输入的两个字节的数据相加，并输出总和。输出中的每一位都应该是输入中与之对应的两个位及进位值之和。


=== components/Shr32 ===

$87104108203785* 对输入进行按位右移
$88430124157796* 32 位右移器


=== components/Mux32 ===

$16638728645850* 二选一选通器
$21257226547838* 32 位数据选择器


=== components/DelayLine64 ===

$80000130396288* 64 位延迟线
$35525647389906* 在下一刻输出此刻的输入值


=== trans/levels_bytw_or_text ===

$21877344150481*
[right]
[color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出
[/right]


=== rpg/maps/prison/shelf ===

$31961489023013* 书架


=== trans/manual_Cyclic recipes ===

$45682345144408* 循环依赖白名单


=== trans/level_flood_predictor_description ===

$24034386495895* 为“海盗瀑布”寻找最合适的建设地点


=== main_scripts/dialogue ===

$95287273202819* 写入

#  hint for odd number
$68750974209145* 要判断两路输入中是否有奇数个 [ON] ，你只需要用到一个元件。

#  hint for the bus
$50799425816171* 利用开关，将不同输入连接到同一条线路上

#  Hint for byte adder
$37093555217568* 你只需用到 8 个全加器。

#  Hint for the maze
$36837749971886*
如果你始终沿着左手边（或右手边）走，那么你最终一定能到达出口。

下面是这种解法的伪代码：
 向前走一步
 左转
 如果面前是墙，那么右转；重复这一步，直到面前不是墙壁为止
 按下交互键（以打开门）
 返回第一步并重复上述操作

#  hint for counting signals
$21044442262778* 用于确定“输出 1”的电路和你在“奇数个信号”这一关里设计的电路是相同的；用于确定“输出 2”的电路和你在“成对的麻烦”这一关里设计的电路基本相同，区别在于这一关里四路输入都为 [ON] 时不输出 [ON]。（至于“输出 3”，我们相信你能自己搞定。——译注）

#  hint for saving gracefully
$25321701584378*
本关里，你需要用到 1 个延迟线元件。搭建电路前，你可以先画一张真值表，这张表的输出行对应着你需要向延迟线元件输入的值。

这个真值表包括三路输入：其中两路是本关自带的输入端子，第三路则是延迟线的输出值。而真值表的输出值则对应着延迟线的输入值。由于带有三路输入，真值表中将有 8 种可能的组合。当你将本关的要求画成真值表后，求解应该就更容易了。
$43114846393781* 读取
$65118645692603* 指令
$53308028631558* 指令

#  Hint for masking time
$46866534894828*
在二进制中，令一个数字对 4 取模等价于仅取用两个最低位。这是因为更高位（表示 4、8、16 等）除以 4 没有余数。
一般而言，对于所有 2 的幂作除数的情况，这种余数与最低位的关系都成立。一个数字的最低 1 位代表 2 的模数，最低 3 位代表 8 的模数，等等。

类似地，在十进制数 4321 中，要得到 100 的模数也很简单（答案是21，忽略百位及以上的数字即可），因为 100 是 10 的幂。

现在，只需要弄清楚如何提取一个数字的最后两位数，你就能通过这一关。
$52150443679969* 继续

#  hint for less
$56438995128380*
首先，你需要确定两路输入中有哪几位是不同的。这可以用 8 位异或运算实现（仅当两路输入的某一位不同时，输出中的这一位为 [ON]）。一旦找到有区别的最高一位后，那么在这一位上为 [ON] 的那一个数字数值相对较大，反之则较小。请留意，我们只需要考虑有区别的数位中最高的那一位，所以对于每一个数位，我们还要用一系列或门来判断更高的数位是否存在差别。
		
最后，对于有符号整数而言，最高位需要单独考虑，因为它与其它的数位的比较结果相反（如果只有一路输入的最高位是 [ON]，那它一定更小，因为它是一个负数）。
$89787506720574* 关闭
$66207112287034* 提示


=== trans/options_ui_scale ===

$78210579950439* 界面缩放比例


=== components/Nand32 ===

$24565725389553* 对输入进行按位与非
$71611588991682* 32 位与非


=== trans/odd_number_error ===

$61530231182650* 你用的元件太多了


=== components/ByteAnd ===

$61791872137683* 对输入进行按位与
$21541105796357* 8 位与


=== rpg/maps/prison/prison_guard ===

$12720535616690*
你不该来这里
机器人！
$48106038104468* 血
$54139682820568* 狱卒


=== components/Counter ===

$51446864816252* 除非被复写，否则每一刻存储值自动增加
$67910883947749* 8 位计数器


=== trans/ide_assembly_codes ===

$62016169253008*
[center]汇编
别名[/center]


=== trans/options_general_title ===

$21908594290225* 通用选项


=== schematics_hub/accept_license ===

$72317516399185* 我同意在 [color=#dd6576][url=cc0]CC0[/url][/color] 协议下共享该作品


=== trans/panel_screen_description ===

$31014036880257* 该屏幕用于提供完成游戏主线各关卡所需要的可视化信息


=== misc/level_close ===

$79455494572697* 继续


=== rpg/maps/overworld/fighter_plane ===

$12257592826946* 我想有一架！
$37870979642704* 战斗机


=== components/Keyboard ===

$40965596602414* 键盘
$76766452660421* 从你的物理键盘上接收按键事件


=== trans/manual_edit_instructions ===

$86365051641280* 编辑指令集


=== trans/dual_ram_output ===

$23716875158240*
输出 1
输出 2


=== trans/level_byte_xor_text ===

$15756501406553*
[right]
[color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出
[/right]


=== trans/panel_xnor ===

$84353654486355*
[right]输入 1
输入 2
输出[/right]


=== levels/unseen_fruit ===

$13023474026617*
你们星球上最令人难忘的是水果，它们确实很美味。

因此我们要在食堂举办一个水果尝鲜活动。
$14259900563789* 传送带上每隔一段时间就会随机送入新的水果。用机器人监控传送带，一旦你看到同种水果出现两次，就立刻转身按下控制面板上的按钮。
$17070232883226* 但我们要确保不会两次送上同样的水果供人品尝，不然场面会很尴尬。


=== component_panels/NoteSound ===

$77965930443088* 自定义音频
$13027096115070* 默认音频
$22175469402467* 无音频


=== levels/conditions ===

$12951779797594*
这个关卡的输入有一个数值和 3 个条件位。

如下图所示，根据 3 个条件位的组合确定要进行的判断类型。并根据所选判断类型检查输入的数值，如果判断为真则输出 [ON]，否则输出 [OFF]。

3 位代码：     以下条件满足时，给出 [ON]：[code]
[OFF] [OFF] [OFF]       Never（从不）
[OFF] [OFF] [ON]       value = 0
[OFF] [ON] [OFF]       value < 0
[OFF] [ON] [ON]       value ≤ 0
[ON] [OFF] [OFF]       Always（总是）
[ON] [OFF] [ON]       value ≠ 0
[ON] [ON] [OFF]       value ≥ 0
[ON] [ON] [ON]       value > 0[/code]
$16407231803964* 当输入 < 0 时输出 [img]dialogue/on.png[/img]

#  Short because it will become the name of a custom component
$40613359684193* COND
$16742265812068* 无论输入为何都输出 [img]dialogue/on.png[/img]
$17616699231679* 当输入 > 0 时输出 [img]dialogue/on.png[/img]
$16632557438774* 当输入 ≠ 0 时输出 [img]dialogue/on.png[/img]
$18234235689107* 当输入 ≥ 0 时输出 [img]dialogue/on.png[/img]
$12429396872036* 无论输入为何都输出 [img]dialogue/off.png[/img]
$19014698800906* 当输入 = 0 时输出 [img]dialogue/on.png[/img]
$13680487623452* 当输入 ≤ 0 时输出 [img]dialogue/on.png[/img]
$12706881725738* 该电路已保存到元件工坊。


=== trans/panel_index_bit_input ===

$47911988603136* [right]输入[/right]


=== trans/manual_instructions ===

$90323246286028* 指令


=== levels/and_gate ===

$15231724707514* 眼下，在地球上所有接受测试的对象中，大象的成绩遥遥领先。考虑到你们大脑的尺寸差异，你做得其实也还不错。


=== trans/panel_neg_description ===

$64810753197096* [center]计算输入值的相反数[/center]


=== trans/level_ram_component_RichTextLabel2 ===

$92123299522120* [center]预期存储值[/center]


=== trans/options_working ===


#  Upload in progress for score sync
$18749833316380* Working


=== trans/map_working_computer ===

$38843517090942* 可运行的计算机


=== trans/panel_decoder1_output ===

$29665974488253*
输出 1
输出 2


=== trans/level_RichTextLabel2 ===

$12683441099336*
[right]输入 1
输入 2
输入 3
输入 4[color=#e49f44]
预期输出
当前输出[/color][/right]


=== trans/manual_program ===

$91120798735036* 程序元件


=== components/Register64 ===

$86007777261800* 64 位寄存器
$99461037008796* 64 位存储单元


=== rpg/maps/overworld/derpoo ===

$86147085986248* 嘶
$46228887292914* 嘎
$95162531064211* 嘶


=== trans/options_resubmit ===


#  Seen after having uploaded a schematic to the hub and then changing the schematic
$13328644005279* 重新提交


=== components/ConfigDelay ===

$31412778600732* 可调延迟线
$84124565448643* 一根可以控制延迟量的延迟线。在调试或调控延迟内存的延迟总时间时很有用。


=== trans/level_bit_adder_RichTextLabel2 ===

$79624864981341*
[right][color=#e49f44]输入 1
输入 2[/color]
预期总和
预期进位
当前总和
当前进位[/right]


=== components/Output8zLevel ===

$49513138880387* 8 位三态输出


=== trans/panel_nor_description ===

$95856050655799* [center]对两路输入进行按位或非运算[/center]


=== levels/RAM ===

$17967666262990* 这一关里，你需要完成如下任务：从输入端依次读取 32 个数值，再按照输入的顺序将 32 个数原样输出。在读取完所有输入前就开始输出将被视作失败。
$13520918982355* 向你的计算机中添加一个内存单元，使之增加 256 个字节的存储空间。你需要用一种技术手段来指定你访问的到底是内存中的哪个位置上的数据。更具体地讲，你需要额外添加一个寄存器，根据这个寄存器里的数值，来确定要访问的内存地址。每次读写内存前，你都需要先更新这个地址寄存器中的地址值。


=== levels/byte_less_i ===

$16755383054285* [center]判断第一个输入是否严格小于第二个。[/center]
$19006843777401* 搭建一个电路，当第一路输入严格小于第二路输入时，输出 [ON]。注意，在本关中，输入应被视作[color=#dd6576]有符号整数[/color]。
$46083799633716* {input_1} 小于 {input_2} 吗？


=== trans/panel_register16_outputs ===

$91613202877683* 输出


=== trans/level_circumference_description ===

$20154743351442* [center]在计算功能的基础上，添加条件跳转功能[/center]


=== trans/panel_halt_label ===

$81678588906692* 中断消息


=== dialogue/schematic_hub/submit_comment ===

$56450764824675* 提交


=== components/Neg16 ===

$17253409670931* 16 位取反器
$57512333327652* 将输入数值的符号反转


=== components/Input 1 ===

$54126599191071* 1 位输入


=== trans/panel_switch_output ===

$86922225714685* 输出


=== misc/instr_delete ===

$91861509153454* 删除


=== trans/level_multiply_description ===

$28761562806647* [center]对两路输入的每一位逐对执行逻辑与运算[/center]


=== trans/level_bit_inverter_RichTextLabel2 ===

$67127889187842*
[right][color=#e49f44]输入
反转[/color]
预期输出
当前输出[/right]


=== components/64Ram ===

$63410290483563* 低逻辑门开销，但读写速度慢的内存
$78790416494254* 内存


=== trans/rpg_complete_text5 ===

$15921686607849* [center]史莱姆农场[/center]


=== trans/panel_network_outputs ===

$68275268516971*
连接 ID
数据 / 端口号 / 错误代码
数据长度


=== components/Nand16 ===

$63870790225686* 对输入进行按位与非
$56507506086622* 16 位与非


=== misc/specification_dialogue ===

$54909668901048* 立即数
$81322935207536* 输入
$92046368194170* 条件
$39935096343723* 永远为假
$52961346176405* {condition} 用 [color=#dd6576]REG 0[/color] 的值覆盖计数器中的值

#  Overture instruction UI
$56175681834727* 当[color=#e49f44]结果 {condition} [/color]
$34974836617918* {register_1} 与 {register_2}
$31185395052385* 输出
$10141348037745* 立即数：{nr}
$98983752580592* 复制
$25145891843959* 永远为真
$53665446068319* 未使用
$26521666422399* 计算
$93899425142858* 从 {from} 复制到 {to}


=== components/Decoder2 ===

$25937877347447* 在 4 路输出中选择一路
$21727998752868* 2 位解码器


=== trans/level_negative_numbers_test_5 ===

$68419648206312* [center]表示[/center]


=== trans/panel_input_right ===

$95766090310621* 右


=== ui/export_select_path ===

$50432926756438* 更改


=== components/Output1z ===

$31478630391268* 只在开关引脚为 [ON] 时输出，否则不输出
$82456670459300* 1 位三态输出


=== trans/panel_xor ===

$89363100135433*
[right]输入 1
输入 2
输出[/right]


=== trans/manual_text_assembly ===

$54465324391961*
你可以使用汇编代码或具体的数值来设定程序组件中存储的数据。汇编代码只是不同数字组合的一组“别名”。例如，与其键入 196 作为“加法”的操作码，不如直接将它命名为“ADD”。合理地设置汇编码能够有效改善代码的可读性，并简化编写流程。

要在汇编代码中添加行注释，请使用 “#”。
[img]dialogue/comment.png[/img]

此外，在一段程序中，你可以使用 [color=#c54d5e]CONST[/color] 关键字来指定一个常量：
[img]dialogue/const.png[/img]

[color=#c54d5e]LABEL[/color] 关键字可以为它所在的那一行的位置指定一个别名。这个关键字在指定程序跳转目标的时候非常有用：
[img]dialogue/label.png[/img]

对于汇编代码中的数值和常量，你可以直接使用进行加（+）、减（-）、乘（*）、整除（/）、取余（%）、按位或（|）、按位与（&）、按位异或（^）运算符。

你可以通过单击行号的左侧来添加断点。程序将在运行到断点处时自动暂停。
[img]dialogue/breakpoint.png[/img]

你还可以将断点添加到任何监视态上，这样一来，当被监视的数值发生变化时，程序也将自动暂停。要添加监视态断点，你只需在编辑器窗口中点击对应的监视态，使其左侧出现一个红点：
[img]dialogue/breakpoint_state.png[/img]

最后, 二进制数值可以通过添加前缀 0b 来指定（所以 5 是 0b0101），而十六进制可以通过前缀 0x 指定（所以 15 是 0x0f）。


=== trans/panel_decoder3_input ===

$82288570082172*
[right]输入 1
输入 2
输入 3[/right]


=== trans/panel_xnor_output ===

$69594087046834* 输出


=== misc/files_preview ===

$15827374884671* 上级文件夹
$14135691870941*
最近编辑
电路图
$81783412663552* 重新同步
$32645745463577* 已被下列元件使用：
$19184997172542* 已被下列架构使用：
$62160230059637* 分享
$36200352866864* 最近编辑
$70617979378677* 查看


=== trans/manual_SpriteDisplay ===

$57792698381638* 精灵显示屏


=== components/SegmentDisplay ===

$56761198694928* 显示数字的小巧工具
$90582128204153* 七段数码管


=== components/Or16 ===

$76807373575014* 对输入进行按位或
$62695381407925* 16 位或


=== trans/levels_adding_bytes_description ===

$11219613205997* [center]对输入的两个数字求和[/center]


=== trans/level_maze_description ===

$25068965294593* [center]控制机器人走到迷宫出口吧[/center]


=== trans/levels_ram_description ===

$52265749461165* 向电路中添加内存单元以通过本关


=== components/Or64 ===

$50631450923181* 对输入进行按位或
$62930122175674* 64 位或


=== trans/manual_text_bytes ===

$73333514253412*
本游戏里，你需要搭建的是一台 8 位计算机。
为了减轻无聊的布线工作带来的额外负担，我们引进了能一次处理一个字节（byte）的导线和元件。一根单字节的导线（8 位线，8 bit line）就是一束虚拟的 1 位导线（1 bit line）。

1 位的导线、引脚使用红绿两色标记信号的状态，而单字节的输入/输出引脚，以及单字节的导线上的数据则都使用整数来标记。


=== trans/manual_robot_controls ===

$94513149242653* 机器人控制指令


=== components/Ashr16 ===

$73288117008611* 16 位算术右移器
$69309153480016* 将输入的数值按位右移，并保持符号不变


=== components/Nor32 ===

$82743668258816* 对输入进行按位或非
$82121937858245* 32 位或非


=== rpg/maps/prison/cat ===

$60970953650633* 猫
$55489562454759* 喵
$33739450565687* 安息吧，猫猫
$66402048769418* 血


=== rpg/maps/prison/control_panel2 ===

$71445934051916* 控制面板


=== trans/panel_decoder2_output ===

$98341196231276*
输出 1
输出 2
输出 3
输出 4


=== trans/panel_maker8_input ===

$26123816206996*
[right]第 1 位
第 2 位
第 3 位
第 4 位
第 5 位
第 6 位
第 7 位
第 8 位[/right]


=== trans/level map colors ===

$35696974632265* 关卡图标颜色


=== components/Not64 ===

$74829633052959* 对输入进行按位非（按位取反）
$81823773658328* 64 位非


=== trans/panel_less_input ===

$68966388936516*
[right]输入 1
输入 2[/right]


=== misc/sandbox_toggle ===

$30516879701896* 沙盒模式


=== trans/manual_side_the_robot ===

$56547245144983* 机器人只能看到前方一格的东西。屏幕右上角这里显示的就是机器人看到的物体名称与编号。这个编号同时也会被发送到电脑的输入设备上。


=== trans/panel_shl_output ===

$75492358516234* 输出


=== trans/panel_register64_inputs ===

$44212297072750*
[right]读取
写入
待写入数值[/right]


=== trans/rpg_hats_looking_at ===

$10758794610945* 前方：13 帽子


=== trans/credit_header ===

$21717110565858* 致谢


=== main_menu/sandbox_button ===

$16857608955464* 沙盒模式


=== trans/level_complete_level_map ===

$20801641140962*
[b]关卡图[/b]
[color=#cccccc][i]点击“[color=#e49f44]继续[/color]”按钮以进入关卡图界面[/i][/color]


=== levels/xnor ===

$11090938799865* 搭建一个和异或门输出相反的逻辑门，即同或门（XNOR）。


=== levels/bit_inverter ===

$15769391111364* 当“反转”引脚处于 [ON] 的状态时，将输入值取反后输出。否则，就将输入值直接发送到输出端。
$59090842372527* 输入
$15272914096446* 这个关卡和你之前通过的“异或门”关卡一模一样。记住，无论我们告诉你这个关卡的目标是什么，真相总在真值表中。
$14944872827527* 尽管有张搞笑的背景图片，你也识破了表象背后无非就是一个异或门而已！干得好。
$16125025706490* 嗯，怎么说呢，也许你在存储器这方面学得有点好过头了……
$12399164863741* 是
$22283233360163* 反转
$66589873978580* 否
$13224963076378* 我们正在试验背景图像如何影响地球生物的认知功能。


=== trans/panel_or ===

$15879871058922*
[right]输入 1
输入 2
输出[/right]


=== trans/options_confirm_reset ===

$55371048386984* 好的


=== components/Shr64 ===

$93124177265670* 对输入进行按位右移
$73798355428095* 64 位右移器


=== misc/hub_comment_label ===

$90173235002118* 评论


=== components/Constant64 ===

$92424468899005* 输出一个常数
$25858905835416* 64 位常量


=== rpg/maps/overworld/grenzorp ===

$29100639060467*
我只是假装工作
实际是在玩电脑游戏


=== component_panels/LatencyRam ===

$87788654491792*
这类内存本该向电路增加额外的 1024 单位延迟量，但我们选择不等延迟内存输出就进入下一刻。这么做能减少电路的延迟总量，代价则是读/写操作无法在当前时钟刻立即完成。

从具体实践角度讲，你的电路总延迟量为 {delay} ，因此一次读/写操作需花费 {ticks} 刻完成。


=== rpg/maps/overworld/sasni ===

$60683848498748*
我不知道为什么我
不坐在椅子上


=== rpg/maps/overworld/barrel ===

$32647427955087* 桶
$15228996460366* 这是一个桶


=== trans/panel_keyboard_description ===

$11215841169495* [center]虽然键盘实时显示按键输入，但只有在一个时钟刻的开始它才会将结果输出到电路之中！[/center]


=== rpg/maps/boss_room/treasure_chest ===

$15644092158788* 战利品


=== trans/always_on_RichTextLabel2 ===

$86547293707045*
[right][color=#ffa502]输入[/color]
预期输出
当前输出[/right]


=== components/Xnor16 ===

$73699169812942* 对输入进行按位同或
$40088995721509* 16 位同或


=== components/Screen ===

$12771040946773* 为某些关卡提供可视化信息
$50037736094411* 关卡屏幕


=== components/Shr16 ===

$20291717268875* 对输入进行按位右移
$31674686871821* 16 位右移器


=== rpg/maps/overworld/tree ===

$72922820287017* 这是一棵树
$33509997611554* 树


=== levels/Calibrating Laser Cannons ===

$11331851878040* 你现在可以使用汇编代码编写你的程序了。汇编代码允许你在编辑器里为指令取一个别名，例如你可以用“add”代替“68”来表示加法。
$11023157447564*
2×π×r

半径 r 是输入值。
你可以将 π 近似为 3 。

计算完成后，请将结果发送到输出设备上。
$15260627694444* 为了校准激光炮，我们需要你借助复杂的数学公式来计算出小行星的周长。
$12669851602178* [center]计算小行星的周长[/center]
$21601709632806* 2π × {radius} 是多少？
$16954408093587* 我们的飞船通常使用激光来摧毁接近的小行星。


=== misc/level_search ===

$30824356356347* 查找关卡


=== levels/circular_dependency ===

$16336401898647* 测试 1/2
$13880985462901* 搭建一个电路，让它的输入受自身输出的影响
$18010308863615*
你需要设计一个“循环依赖”的电路。这个电路中的输入依赖于它自身的输出。当发生循环依赖时，我们可能会很难确定元件产生的输出，因为你需要首先确定输入是怎样的，但要确定输入又需要先确定元件的输出，……所谓“循环”指的就是这种套娃式的依赖关系。

这种状态在本游戏其它所有关卡中都是不允许出现的，只有本关例外。本关的目标恰是需要你构造这样一个电路，这样你在进入下一关以前就会对这一情形有更深入的了解。
$13520037133129* 我不清楚这对学生有没有好处，但是老师们都很喜欢这么干。
$11316928751185* 在我们的教育系统中，传统的教学方法是骗学生走错误的路，然后对他们发出大声嘲笑。
$74003370318715* 核对


=== components/Ashr8 ===

$45194709458499* 将输入的数值按位右移，并保持符号不变
$97418270861318* 8 位算术右移器


=== trans/options_language ===

$30910326565868* 语言


=== ui/top_bar/scores ===

$68953385743184* 门数量：


=== trans/panel_input_direction ===

$25170203412473* 标签方向


=== trans/rpg_decoartion ===

$31542517516487* [center]顶栏的 [i][img]res://rpg/heart.png[/img][img]res://rpg/heart.png[/img][img]res://rpg/heart.png[/img][/i] 只是装饰！[/center]


=== components/Input64 ===

$98777983100258* 64 位输入


=== components/Input 4 ===

$11447837612693* 输入


=== trans/level_component_factory_Label2 ===

$37347658035959* 组件预览


=== trans/or_gate_3_RichTextLabel2 ===

$56903547636751*
[right][color=#e49f44]输入 1
输入 2
输入 3[/color]
预期输出
当前输出[/right]


=== trans/tick_label ===

$39906291838542* 时钟刻


=== components/Output16z ===

$54782010205016* 16 位三态输出
$54278394672948* 只在开关引脚为 [ON] 时输出，否则不输出


=== trans/manual_short_circuit ===

$41209541005460* 短路


=== trans/manual_text_turing_complete ===

$54897112350567*
生活中常见的不少计算机（比如说计算器）只能执行种类有限的某些算法。

它们不能执行需要任意次循环或递归的计算。从技术上来说，不能执行循环或递归的机器只能执行组合逻辑运算。

与此相对，图灵完备的机器却很强大。图灵完备的机器可能只有一个非常慢的 CPU ，但这并不影响它的强大，因为它可以执行任何理论上可计算（computable）的算法。


=== components/ByteMul ===

$56549841656852* 8 位乘法器
$68631919890554* 将两路输入值相乘


=== trans/panel_fileloader_output ===

$26334594715602* 输出


=== trans/map_assembly_challenges ===

$31733554125775* 汇编挑战


=== levels/1_decoder ===

$16057674753878* 搭建一个可以在两个输出端间切换的电路。


=== levels/byte_mux ===

$15428393549821* 选通输入
$49305362057225*
当前输出 {your_answer}
预期输出是 {correct_answer}（选通 {input} 路输入）
$18296416014178* 当选通输入端为 [OFF] 时，将 A 路输入发送到输出端，否则将 B 路输入发送到输出端。
$17093993196554*
虽然他没能通过我们的测试，但我们最终决定留下他的狗。和其他的地球生物不同，狗狗毛茸茸的，还能遵守简单的命令。

我们也许会要你们俩组队，因为你们的优缺点正好彼此互补。


=== component_panels/FileRom ===

$28789952270889* 无
$89182778159982* 当前默认：{file_name}


=== trans/level_capitalize_description ===

$31869433910274* 将每个行星名字的单词首字母大写


=== trans/level_byte_constant_description ===

$84789919073603* [center]始终输出数字 164[/center]


=== misc/component_factory_toggle ===

$55499239951858* 元件工坊


=== rpg/maps/unseen_fruit/door ===

$40261193416765* 门
$76111330686725* 此门已锁


=== trans/panel_keyboard_left ===

$44556588975494* [right]读取下一个按键事件[/right]


=== trans/map_basic_logic ===

$75078723880086* 基础逻辑电路


=== trans/panels_clock_output ===

$79367841142406* 时钟信号


=== misc/reset ===

$39440928972984* 复位（快捷键：F4）


=== components/And3 ===

$19664974941910* 三路与门
$86839706221116* 有 3 个输入引脚的与门


=== components/Or32 ===

$92752025948920* 对输入进行按位或
$40180779432911* 32 位或


=== components/Add32 ===

$91616185859914* 对两路输入求和
$64111401384153* 32 位加法器


=== trans/level_robot_racing_description ===

$67533273328897*
让机器人沿赛道运动至终点
请用尽可能短的程序来实现这一目标


=== components/Level Gate ===


#  This must be no more than 6 characters long, use abbreviations if necessary
$91472284749011* 延迟量

#  This must be no more than 6 characters long, use abbreviations if necessary
$86260137015175* 时钟刻

#  This must be no more than 6 characters long, use abbreviations if necessary
$84124240406304* 总开销

#  This must be no more than 6 characters long, use abbreviations if necessary
$54172257277874* 合计

#  This must be no more than 6 characters long, use abbreviations if necessary
$15265492169229* 门数量


=== nim/backend ===

$64492620873138* 始终输出
$98703677236827* 1 分钟前
$86244493049244* {hours} 小时前
$95018143828198* 1 年前
$10792411581963* {size} MB
$21685594109067* 刚刚
$91048993146856* 保存
$98363990684104* 1 小时前
$84076931764831* 1 天前
$58374689721038* 字节
$98683857303458* {size} 字节
$88592386859564* （最差测例：{worst_trial}）
$86391754618645* {size} KB
$18300496139706* 1 个月前
$17901039729248* {months} 个月前

#  This is a file name
$96230605270081* new_program
$31567406591202* 1 字节
$82336838435736* 加载
$42553566189409* {minutes} 分钟前
$70945526841433* {years} 年前
$81432548841957* （首次测试耗时）
$22729457392140* {size} GB
$14036822471924* {days} 天前
$18816732910302* 保存数值
$38412380622852* 无法从“{path}”处读取文件


=== components/NEG ===

$88379907297327* 8 位取反器
$62021716182809* 将输入数值的符号反转


=== trans/options_redo ===

$50610605761210* 恢复


=== components/Output8z ===

$58449766432492* 只在开关引脚为 [ON] 时输出，否则不输出
$66776427840721* 8 位三态输出


=== trans/instructions_hint ===


#  Seen the first time you open thte "instruction" menu 
$65105856275770* [center][color=#c5c5c5]点击数位以改变数值[/color][/center]


=== misc/program_edit_button ===

$38481453712356* 编辑程序


=== components/DivMod32 ===

$61314390474120* 对两路输入作除法，输出商和余数
$84309999871615* 32 位除法器


=== trans/panel_mux_input ===

$23495704401199*
[right]选通输入 1 / 2
输入 1
输入 2[/right]


=== components/And16 ===

$56198785587874* 对输入进行按位与
$26727645933234* 16 位与


=== trans/manual_De Morgan's laws ===

$67837328811108* 德·摩根定律


=== trans/level_capitalize_output ===

$37037455015862* Output


=== components/And64 ===

$80790829001391* 64 位与
$89424947351456* 对输入进行按位与


=== trans/rpg_press_any_key ===

$66322253595450* [center]按任意键重试[/center]


=== rpg/maps/overworld/ogoxo101 ===

$71158910763961*
听说了吗，在地球上
连一台机器人
都没有起义过?


=== trans/panel_splitter64_output ===

$70335236543238*
第 1 字节
第 2 字节
第 3 字节
第 4 字节
第 5 字节
第 6 字节
第 7 字节
第 8 字节


=== levels/bit_adder ===

$13109388951000* 我们用数字丈量宇宙。 所以你造的电脑必须学会计数。
$90120091310928* 总和
$48208190309258* 进位
$16564356062672*
如果输入为 [OFF]，将它视作 [ZERO]，如果输入为 [ON]，将它视作 [ONE]。以二进制方式将它们相加，使结果为 [ZERO] 或 [ONE]。

与普通加法一样，如果结果不能用一位数来表示，将进位数设为 [ONE]。


=== trans/options_inline_latches ===

$53886441687616* 允许特定循环依赖（详见手册）


=== rpg/maps/overworld/reactor_entry ===

$81583424078503* 废料口


=== levels/double_number ===

$74261206899285*
你的答案为 {input} × 2 = {your_answer}
正确答案为 {input} × 2 = {correct_answer}
$19766257822639*
本关的输入端子和输出端子接收的不再是 1 位信号，而是单字节（8 位）信号。在本关中，你将获得两个新的元件，第一个是分线器，它能将一条单字节导线（8 位线）分割成八条 1 位导线；第二个是集线器，它能将八根 1 位线组合成一根 8 位线。

利用这些元件，找到一种让输入翻倍的方法（本关输入范围为 0~127 的整数）。


=== components/LessI32 ===

$87609006355839* 32 位小于比较器（有符号）
$99994775592318* 判断输入 1 是否严格小于输入 2


=== trans/map_available ===

$81707212583931* 已解锁


=== trans/manual_text_negative_numbers ===

$85226853816564*
你在“负数”这一关里发现的表示负数的方法叫做“补码”（two's complement）。它是现代计算机中表示负整数的标准方法。补码的主要优点在于，在这种表示方式下，我们针对无符号整数设计的加法器能直接用来处理带负数的计算。

在计算机科学发展的早期，“反码”（one's complement）是补码的主要竞争者。它的主要优点是，改变一个数字的符号很简单，你只需将数字中的每一个位都翻转。然而，对于数字 0 它有两种表示方法，即“正零”与“负零”，这使得比较操作的处理更加麻烦。

还有一种有趣的表示方法是“负二进制”（base -2），这种表示方法中，每一位的符号都和它相邻的数位相反。


=== trans/panel_switch_enable ===

$84515289220335* [right]启用[/right]


=== trans/options_window_mode ===

$54328660964287* 窗口模式


=== trans/options_console ===

$96601731563408* 打开控制台


=== trans/panel_bitmemory_inputs ===

$47585933412781*
[right]启用写入

待写入数值[/right]


=== misc/level_gate_component_icon ===

$83440578602427* 解锁元件


=== trans/options_save_location ===

$61172959716558* 存档路径


=== components/Output 1 + 1B ===

$43917122084061* 接收测例输出
$81929942356043* 关卡输出


=== misc/hub_search ===

$76770986264566* 搜索


=== component_panels/Input3Conditions ===

$26016934287702* ALWAYS
$23280572780712* NEVER
$41356418485569* VALUE≥0
$66462144102272* VALUE=0
$62118687143343* VALUE≤0
$60761142691177* VALUE>0
$94629088310936* VALUE≠0
$45120343226481* VALUE<0


=== misc/solution_option ===

$21618236951146* 查看解法


=== trans/panel_register64_outputs ===

$55631089130544* 输出


=== trans/map_programming ===

$44937904689376* 编程


=== components/DelayLine16 ===

$61925612221077* 16 位延迟线
$65706144678496* 在下一刻输出此刻的输入值


=== rpg/maps/overworld/coin ===

$26007076735159* 金币


=== levels/divide ===

$16412715945615* [center]将两个数字相除[/center]
$14525870461271*
对输入的两个数值作除法，输出商和余数。例如，在除法 7÷3 中，7 被 3 减 2 次后还剩下 1。这里 2 就是[color=#e49f44]商[/color]，1 就是[color=#e49f44]余数[/color]。
在这个练习中，你需要依次从输入端读取被除数（上例中为 7）和除数（上例中为 3），然后输出对应的商和余数。
$76454016047920* {numerator} / {denominator} = {quotient}（余 {remainder}）


=== trans/manual_RGB_color ===

$62337044104456* RGB 真彩色


=== trans/panel_maker8_output ===

$67169082367526* 输出


=== components/Output 4 ===

$90190739202646* 输出


=== components/Rom ===

$24976506406652* 只读存储器
$81743370431597* 只读存储器（沙盒模式可写入）


=== misc/instruction_expand ===

$44690074039467* 展开规则定义


=== trans/level_byte_adder_you_carry_text3 ===

$65048723622767* 总和


=== rpg/maps/spacial_invasion/crate ===

$73286408216451* 板条箱
$28875169677730* 碎片


=== trans/level_tick_tock_description ===

$34658332565777* [center]将计数器里存储的值加 1 ，或用新的输入值将其覆盖[/center]


=== components/IndexByte ===

$27264669944539* 字节抽取器
$54699455184164* 从一根多字节导线中抽取某个字节的数据


=== component_panels/Hdd ===

$99685372736199* 磁头位置：{pos}


=== components/Bidirectional16 ===

$31038378395810* 16 位双向端子
$99604485981015* 可以用于规避某些循环依赖的错误


=== trans/panel_nor ===

$59430016039613*
[right]输入 1
输入 2
输出[/right]


=== components/Register ===

$19705753304166* 8 位存储单元
$68946767861738* 8 位寄存器


=== trans/panel_segment_select_color ===

$90642877666116* [center]选择颜色[/center]


=== trans/level_division_headers3 ===

$81978438070842* 商


=== trans/complete_flower_text3 ===

$81122931510261* [center]任务[color=#e49f44]完成[/color][/center]


=== trans/wire_comment ===

$41481492318983* 线路注释
$87836369268219* 保存修改
$34083666001769* 线路注释


=== levels/odd_number_of_signals ===

$16173829560311* 本关里你最多只能使用 3 个元件。只有当奇数个输入为 [ON] 时才输出 [ON]。
$85589489148198*
已使用的元件
{nr} / 3
$18288998816979* 这一关有一个[color=#e63e5b][url=odd_number]提示[/url][/color]。如果卡关了，你可以查看它。


=== misc/wire_color ===

$78287906849040* 导线颜色


=== rpg/maps/overworld/cannon ===

$34523773807049* 激光炮


=== misc/overwrite_custom ===

$26401730066442* 自定义组件“{comp}”已存在。你希望覆盖它么?


=== levels/3_decoder ===

$19231618567710* 有 3 位的输入，就有 8 种可能的输入状态组合。请搭建一个电路，利用三位输入信号，在 8 路输出中选取一路激活（输出 [ON]）。注意，每次必须有且仅有一路输出处于 [ON] 的状态。
$14293122338496* 我们让实习生给这个元件添加了一个“禁用”位。我们受不了他总是四处转悠、恳求我们给他一点无聊乏味的活儿来做。


=== trans/panel_probewirebit_description ===

$36861847387280* 探针可将自定义元件中存储的某个值显示在其表面，或链接到程序编辑器的监视槽上


=== trans/panel_input1_input_0 ===

$76697231893680* 输入


=== trans/panel_matrix_input2 ===

$11173083690745* [right]启用 X[/right]


=== levels/constants ===

$17098439090371*
我们需要一种方法将我们存放在程序中的数字直接写入到寄存器中。为了做到这一点，当指令的最高两位为 [OFF][OFF] 时，我们要让计算机切换到立即数（Immediate）模式。

在立即数模式中，输入的单字节参数将被视为一个数字（而非地址），它将被写入 0 号寄存器（REG 0）中。这意味着我们可以直接
[SAVE] 0 到 63 之间的字面值。


=== trans/options_select_all ===

$21380256293472* 全选


=== components/BNOT ===

$53686485035156* 8 位非
$26822227902426* 对输入进行按位非（按位取反）


=== components/Ror64 ===

$43920264894591* 64 位循环右移器
$49583010717958* 对输入执行按位循环右移


=== levels/Arithmetic Engine ===

$16434409050195*
为你的电路添加加减运算能力。

实现以下指令：
[code][color=#87a8c8]0 OR（或）
1 NAND（与非）
2 NOR（或非）
3 AND（与）
4 ADD（加）
5 SUB（减）[/color][/code]
$87042161621333* 操作码
$20357619206641* 输入 2
$94622250037548* 输入 1

#  Short because it will become the name of a custom component
$14243962965012* ALU


=== rpg/maps/unseen_fruit/fruit ===

$74585814142093* 黑莓
$59609837209455* 番茄
$15802853329735* 猕猴桃
$79445215329265* 梨
$78424930494044* 水果
$18469474055437* 西瓜
$60053656119333* 金苹果
$51779877620644* 苹果
$31466825108080* 橘子


=== rpg/maps/cave/rock ===

$69774075054633* 石头


=== components/Rol8 ===

$79612280948390* 8 位循环左移器
$55557725551789* 对输入执行按位循环左移


=== components/OR ===

$13013154620359*
当任一输入为 [ON] 时输出 [ON]
[table=5]
[cell]输入 1[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]输入 2[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]输出[/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell][cell][ON][/cell]
[/table]
$97247779246257* 或门


=== trans/panel_regredplus_input ===

$88713386551026*
[right]读取
写入
待写入数值[/right]


=== trans/hub_add_comment ===

$56654968471533* 添加评论


=== levels/not_gate ===

$19085882338208*
[b]操作指南[/b]
右键单击以取消选择
$10042327259531* 既然你已经解锁了与非门，那么接下来你就可以开始学着搭建一些电路了。
$14042842216181* 上一关里，你填好了一个与电路的输出相匹配的真值表。这一关里，你的任务是搭建一个与给定的真值表匹配的电路。
$10604720087324*
[b]操作指南[/b]
创建与该真值表相符的电路。
点击左上角的 [i][/i]（下一刻）图标以测试每种输入组合下的结果。
一旦两个组合都通过了测试，你就通过了这一关。
$19798729463813*
利用与非门（NAND），搭建一个非门（NOT）

可用工具：[b]与非门（NAND）[/b]
[code]输入 1：[OFF][ON][OFF][ON]
输入 2：[OFF][OFF][ON][ON]
输出：  [ON][ON][ON][OFF][/code]

搭建目标：[b]非门（NOT）[/b]
[code]输入 1：[ON][OFF]
输出：  [OFF][ON][/code]
$18442122157391*
[b]操作指南[/b]
单击背景空白处以取消选择
$12880883686501*
[b]操作指南[/b]
点击右上角的与非门（NAND），并将其放置在电路图中                          
$18780831606716*
[b]操作指南[/b]
在窗口中按住左键拖动，来添加一根导线


=== components/IndexBit ===

$89611629299917* 位抽取器
$84431924133490* 从一根线路中抽取某一位上的数据


=== components/Output 2 ===

$73255344581755* 输出


=== misc/options_ui_scale ===

$49650951662549* 保存


=== components/Nor16 ===

$57921392198825* 对输入进行按位或非
$69522380057631* 16 位或非


=== components/Input32 ===

$31482038708224* 32 位输入


=== components/Input 1B CODE ===

$16878300327380* 操作码


=== components/LatencyRam ===

$74156976676497* 延迟内存
$31261866779127* 与普通内存相比延迟量更低，代价是需要数个时钟刻才能完成读写操作


=== components/BOR ===

$19406015796751* 对输入进行按位或
$54190050450484* 8 位或


=== components/Ror32 ===

$84788620524361* 32 位循环右移器
$50013003040535* 对输入执行按位循环右移


=== trans/turing_complete ===

$35911376069529* 图灵完备


=== components/BitSwitch ===

$56917313833836* 切换一位线路通断
$41574334638147* 开关


=== rpg/maps/overworld/misuni ===

$54042082821022*
我听说在这艘飞船上的某个地方
藏有一个装满金币的宝箱。


=== rpg/maps/prison ===

$63369063884491* 坏机器人！


=== components/ByteLessI ===

$52765625016236* 判断输入 1 是否严格小于输入 2
$25403981009644* 8 位小于比较器（有符号）


=== misc/FileInput ===

$28866575833369* 从你的硬盘上加载文件
$34159012148766* 文件加载器
$47320399181598* 未选择文件


=== misc/overture_add_assembly ===


#  Overture custom instruction interface (disappears when you complete the Turing Complete level)
$10565133223872* Never

#  Only shown in the first programming level
$62421757655527* 给汇编码输入一个别名，并单击保存。
$63525237058165* 从 {source} 处将数据复制到 {destination}
$24281479096246* 当[color=#2b8738]结果[/color] {condition} 
$32873193471770* UNUSED
$88446594314360* 设置立即数：{number}

#  Overture custom instruction interface (disappears when you complete the Turing Complete level)
$94278717238239* Always
$79398554520691* 对 {reg_1} 和 {reg_2} 的值执行 {opcode} 操作
$72740868980397* {condition} 用 {register} 的值覆盖计数器中的值 


=== trans/or_gate_RichTextLabel2 ===

$56663370211115*
[right][color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出[/right]


=== levels/binary_count_down ===

$56999237564848* 剩余 {x} 秒
$41793938939207* 时间到


=== misc/save_size ===

$71918065858983* 保存


=== components/Timing ===

$96011300295966* 系统时间
$78774996925434* UNIX 时间戳（单位：微秒）


=== rpg/maps/overworld/dr draco ===

$23996965687702*
我对我的床很不满意
毯子都盖不住我的脚。


=== components/Output32 ===

$82172858698449* 32 位输出


=== trans/level_complete_level_complete ===

$49647690443210* [center]关卡完成[/center]


=== trans/component_output_sum_label ===


#  Label appears on the component and must be 3 letters or less
$92505830860215* SUM


=== trans/options_setting_export_assembled ===

$98549046707456* 输出二进制汇编代码


=== trans/options_setting_click_to_pan ===

$24654961601456* 左键拖动平移视图


=== components/Halt ===

$30351143139905* 中断器

#  This is the default message of the Halt component
$54106972240596* 挂起
$62990744955549* 中断程序运行，并输出一条消息


=== components/Mul32 ===

$98530670555665* 32 位乘法器
$51210946736766* 将两路输入值相乘


=== trans/panel_program_1edit_program ===

$65592803016716* 编辑程序


=== levels/byte_nor ===

$60887380748746* 搭建一个电路，对两个单字节输入执行按位或非运算。


=== rpg/maps/dance/dancer ===

$47779544732987* 舞者


=== rpg/maps/overworld/flankidorp ===

$55603111039626* 今天的炖菜特别好吃！


=== components/Bidirectional1 ===

$95836352586032* 可以用于规避某些循环依赖的错误
$34912798641933* 1 位双向端子


=== trans/component_panel_latency_RichTextLabel ===

$29766254362093*
[right]读取
写入
地址
待写入数值
待写入数值
待写入数值
待写入数值[/right]


=== trans/rpg_you_died ===

$66723789644528* [center]你[color=#eb5260]死[/color]了[/center]


=== trans/level_wide_instructions_description ===

$60538893544456* [center]搭建一个支持宽指令的程序元件[/center]


=== misc/program_edit ===

$57861256694537* 第 {bytes_from} 到 {bytes_to} 字节


=== misc/delete ===

$53448014080434* 删除（快捷键：右键）


=== levels/call_ret/yes ===

$27017757250898* 是


=== components/LevelInput1 ===

$12746117288689* 输入


=== misc/controls2 ===

$38773676077206* 编辑指令集
$98116750645182* 浏览手册页面


=== levels/negative_numbers/test ===

$64427417171037* 测试


=== trans/pabel_or3 ===

$77994083578205*
[right]输入 1
输入 2
输入 3
输出[/right]


=== trans/manual_binary ===

$19098578855427* 二进制


=== trans/options_comment_wire ===

$96449970906640* 添加线路注释


=== trans/panel_and3 ===

$96299326024757*
[right]输入 1
输入 2
输入 3
输出[/right]


=== trans/manual_terminology ===

$13311390759928* 术语词典


=== trans/level_byte_adder_you_carry_text2 ===

$87943759248740* 输出进位


=== misc/factory_back ===

$98930461722118* 返回


=== trans/panel_mux_output ===

$15170071160680* 输出


=== trans/panel_equal_input ===

$51485224340167*
[right]输入 1
输入 2[/right]


=== components/Xnor8 ===

$45789912406647* 对输入进行按位同或
$31985293401482* 8 位同或


=== trans/level_bit_switch_RichTextLabel2 ===

$57920867194992*
[right][color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出[/right]


=== trans/manual_sprite_display ===

$28358052747011*
精灵显示屏（sprite screen）是一个 640x480 像素的小块贴图显示屏。在使用精灵屏幕之前，你首先需要指定一张精灵拼合图（sprite map，由小方块贴图拼合成的大图片），这是一个包含所有精灵（sprite，即一张小方块贴图）的 PNG 格式图像。你可以通过点击元件，在窗口下方的组件面板中选择精灵拼合图。

元件的第一个输入引脚用于指定指令类型（[color=#e49f44]Command type[/color]），接下来 3 个引脚的含义取决于第一个引脚输入的指令数值，具体如下所示。精灵 ID（Sprite ID）是一个 8 位的数字，代表图层编号；而位置（Position）和尺寸（Size）则分别是一对 16 位的值（因此各自都需要16 * 2 = 32 位的输入）。

[table=2]
[cell]0[/cell] [cell]No command[/cell]
[cell][/cell][cell]无操作[/cell]
[cell]1[/cell] [cell][color=#e49f44]Load sprite[/color] (Sprite ID, Offset in image, Size in image)[/cell]
[cell][/cell][cell][color=#e49f44]加载小贴图[/color] 参数：(精灵 ID, 坐标偏移量, 小贴图尺寸)[/cell]
[cell][/cell][cell][i]为一个 sprite ID 指定对应的小贴图。该贴图在拼合图的坐标由 Offset 值（由第三个引脚输入）给出，尺寸则由 Size 指定。[/i][/cell]
[cell]2[/cell] [cell][color=#e49f44]Set position[/color] (Sprite ID, Position on display)[/cell]
[cell][/cell][cell][color=#e49f44]设置图片坐标[/color] 参数：(精灵 ID, 显示位置)[/cell]
[cell][/cell][cell][i]该模式下，由第三个引脚输入的数值 (X, Y) 将指定已加载的小贴图在显示屏上出现的位置。[/i][/cell]
[/table]

[center][img=300]dialogue/manual/sprite_screen.png[/img][/center]

注意，每个小贴图都处在一个单独的图层上。图层的顺序由 Sprite ID 确定。
要删除一个图层，只需让对应的 Sprite ID 加载一个尺寸为 0 的贴图即可。


=== levels/or_gate ===

$12749704931323* 高兴点，地球人。能参与我们的实验是你的荣耀。
$11472059692644* 你可是获得了与银河系中最先进的文明对话的良机。


=== levels/full_adder ===

$17063157033479*
在上一关中，我们对两路输入进行了求和，这一关里我们将对三路输入求和。和上一关一样，你需要将输入以二进制方式相加，把结果用 [ZERO] 或 [ONE] 表示出来。

与普通加法一样，如果结果不能用一位数来表示，将进位数设为 [ONE]。
$74173200701943* 总和
$67922993335648* 进位


=== components/3_decoder ===

$59129788113517* 在 8 路输出中选择一路
$94375716460090* 3 位解码器


=== components/Equal32 ===

$32710942647020* 32 位判等器
$32433537137277* 判断两端输入是否相等


=== trans/panel_rom_setting_labels ===

$95314636684817*
[right]容量（字节）：

数据位宽：[/right]


=== nim/backend_lib/custom_component ===


#  Default new input pin name for custom compoennts
$64951951489108* 输入

#  Default new output pin name for custom compoennts
$94864122622568* 输出

#  Default new bidirectional pin name for custom compoennts
$94089252493268* 双向引脚


=== misc/menu_schematic_hub ===

$13921098180953* 分享中心


=== components/Byte Expander ===

$60488114435022* 将一根 8 位线拆分为八根 1 位线
$21904470559153* 8 位分线器


=== ui/toggles/level_log ===

$38557550573896* 关卡说明


=== misc/instruciton_rule_label ===

$70464083627337* 标签文本


=== misc/change_schematic ===

$79554853897000* 切换电路图


=== misc/ide_new_program ===

$20397881687313* new_program


=== trans/panel_not_description ===

$36935580253321* [center]按位反转输入值[/center]


=== components/Shl32 ===

$38930281262898* 32 位左移器
$88685329847417* 对输入进行按位左移


=== components/DivMod8 ===

$37666366877853* 对两路输入作除法，输出商和余数
$44959426271423* 8 位除法器


=== trans/panel_decoder2_input ===

$31844862767401*
[right]输入 1
输入 2[/right]


=== trans/level_program_description ===

$44017405175202* [center]使用程序元件替换指令输入[/center]


=== misc/menu ===

$56916384895438* 主菜单


=== trans/level_odd_ticks_RichTextLabel3 ===

$89508766742523*
[right]输入
预期输出
当前输出[/right]


=== misc/save_schematic ===

$36331525379247* 保存该电路图


=== rpg/maps/cave/slime ===

$57665128042496* 粘液球
$58067186899637* 史莱姆


=== rpg/maps/overworld/duplaat ===

$48841712525408* 呣 呣 呣


=== trans/options_colorblind ===

$49806848871093* 色盲辅助模式


=== trans/panel_decoder1_description ===

$77460843937727* [center]根据输入值，选择一路输出将其激活（输出高电平）[/center]


=== trans/panel_register8_inputs ===

$13844216291005*
[right]读取
写入
待写入数值[/right]


=== components/Neg32 ===

$26991597084705* 32 位取反器
$35735598635057* 将输入数值的符号反转


=== components/InputConditions ===

$75386511637758* 条件
$71663355611979* NEVER
$84163806515429* =0
$63748269806736* <0
$71425442219836* ≤0
$53856166132912* ≥0
$48141874604871* ALWAYS
$73802979424247* ≠0
$45382684265289* >0


=== trans/level_dependency_description ===

$81238724438578* 搭建一个电路，让它的输入受自身输出的影响


=== trans/level_sorter_description ===

$60186094365455* 对输入数据进行排序


=== dialogue/schematic_hub/search_button ===

$99419261731746* 搜索


=== trans/panel_input_input_1 ===

$82781946969262* 输入 2


=== trans/manual_keynote_the_robot ===

$90224489436893* 可使用方向键控制机器人移动


=== trans/options_pan_up ===

$80031998727851* 视图上移


=== levels/maze ===

$13225915898937*
如果你打算继续完成后面的关卡，我会向你传授关于内存、栈和函数调用的神秘知识，你也将有机会接触到更多像这关一样有趣的挑战。
		
不过首先，你得设计一台更好的电脑。作为从零开始搭建的第一台计算机，[color=#e49f44]OVERTURE[/color] 表现得还不错。但是它很笨拙，编出的程序也是一团乱麻。如果你不想在面对后续挑战的时候掉光头发，就需要搭建一个更强大的架构—— [color=#e49f44]LEG[/color] 架构。
$39698491148180* 墙
$17275059688693* 恭喜，你通过了我们的测试！干得漂亮！
$13741358519166* 传说中的迷宫。如果你解决了这个难题，你就通过了测试！
$92831124744885* 无
$39079200383267* 门
$95516682647996* 金币
$11103446544344* 或者，你也可以稍事休息。放松一下吧，从现在起，你不必再担心会被我们吃掉了。
$19331074553774*
编写一段程序，实现让机器人走出迷宫的算法。

本关有一定难度，为了理清思路，你可以在着手编写程序之前，先写一下算法的伪代码。

如果仍然觉得太困难的话，不妨看看这个[color=#e63e5b][url=maze]提示[/url][/color]。

[tip]请牢记立即数不能大于 63 这一限制。在本关里常常出现的错误，就是试图让程序跳转到第 63 行以后的位置。[/tip]


=== trans/level_byte_adder_question2 ===

$85899338356278*
[right]预期结果

当前结果[/right]


=== trans/level_constants_text ===

$29779449172278*
[right][color=#e49f44]指令
输入[/color][/right]


=== trans/level_complete_stat_tick ===

$47758922161853* 时钟刻


=== rpg/maps/overworld/glob ===

$94714343285743*
激光炮没有正确校准
我们被一颗小行星击中了


=== components/Rol16 ===

$48583573494467* 16 位循环左移器
$73379230742631* 对输入执行按位循环左移


=== trans/levels_not_RichTextLabel3 ===

$48425594158515* 搭建非门


=== trans/level_complete_signed_numbers ===

$41649402437253*
[b]负数[/b]
[color=#cccccc][i]在有符号数
和无符号数之间切换[/i][/color]


=== trans/options_synced ===

$99411066573242* 记录已上传


=== trans/optoins_factory_reset ===

$17721051281188* 恢复出厂设置


=== components/Equal16 ===

$97954874255512* 判断两端输入是否相等
$33633607925660* 16 位判等器


=== trans/panel_rom_setting ===

$99326144894013* 设置


=== trans/panel_program8_1_input ===

$36858295122746* [right]地址[/right]


=== trans/level_signed_negator_labels3 ===

$66996894079719* 预期输出   当前输出


=== trans/manual_text_hard_disk ===

$82372297690518*
硬盘是由高速旋转的磁性碟片和带有磁头的机械臂组成的存储设备。为存取数据，机械臂必须进行物理上的移动，而机械运动与电子元件的工作速度相比可谓是极端缓慢。因此现实中操作系统一般都会尝试优化读写操作，以尽可能减少磁头移动的次数。

游戏中的硬盘元件有一个“寻道”（seek）引脚。这个引脚允许你将当前的读写地址进行指定数量的偏移。偏移后的地址采用循环偏移方式进行计算，这意味着从 0 地址开始向前偏移 1 字节会到达地址最高处，而从此处向后偏移 1 字节又会回到地址最低处。


=== levels/ai_showdown ===

$14940806461794*
它唯一的弱点是好赌。我们已经吸引了它的注意力，让它跟你来打牌。它跟我们保证，如果你赢了，它就投降。
一定要赢，你是我们唯一的希望了！
$91952386315199* 回车：观察 AI 的行动
$61844622314350* 回车：取走 1 张牌
$63022840108406* NAK 02 取走了 1 张牌
$38249859598461* 你赢了！
$17297225655678* NAK 02 是我们的智能工程机器人。它很聪明，但有些时候会耍流氓，甚至在飞船上煽动叛乱。
$18848103966031*
游戏规则：桌面上共有 12 张牌，玩家和机器人轮流取牌，每次只能取走 1~3 张牌。玩家先取，取走最后一张牌的一方失败。

输入端接收的数值为当前桌面上剩余的纸牌数量。向输出端发送数字 1、2、3 ，则玩家取走对应数量的纸牌。NAK 02 会在玩家之后立刻采取行动，所以玩家可以在输出数值后立即读取输入，来获取机器人采取行动后的剩余牌数。
$43263885242501* 你输了！
$33425880719824*
使用方向键
选择要取走的牌
$37273944507773* NAK 02 取走了 {nr} 张牌
$86631925987075* 回车：取走 {nr} 张牌
$85996414406804* 回车：观察 AI 的行动
$11794110848012* 这一回它又占据了飞船主控室，还劫持了船长。


=== trans/panels_bidirectional_set_z_label ===

$50319299760169* 无输入：


=== trans/panel_segment_enable ===

$14963127967678* [center]启用[/center]


=== trans/level_complete_stat_sum ===

$99546064626994* 总开销


=== components/Mux16 ===

$75979055121665* 16 位数据选择器
$13997767115693* 二选一选通器


=== trans/manual_delay_text ===

$52013630755752*
信号流经所有的元件都会产生延迟。这一点对真实硬件来说很重要，因为电路的延迟量决定了它运行速度的上限。 

跟随数据导线从输入端口一路走到输出端口，沿途经过的所有元件的延迟量之和便是这条路径的总延迟量。一个电路的延迟量则由最慢的那条路径的延迟量决定。

除了输入端口外，计算延迟量时，路径也可以从任何没有圆形输入引脚的元件开始（比如计数器和常量元件），在任何方形引脚处结束。

此外，自定义元件的延迟量不是按照其中最慢路径的延迟量进行统一计算，而是分别计算每个输出引脚的延迟量。这种计算方式不会令高速引脚被低速引脚所拖慢，也避免了让用户使用自定义元件时遭受额外的分数惩罚。


=== trans/panel_fileloader_offset ===

$78662357115684* [right]偏移量[/right]


=== ui/options/Controls ===

$53266310714298* 控制


=== nim/backend_lib/level_list ===

$58391129129347* 寄存器之间
$45936227746026* 计数器
$16881141174140* 二进制速算
$12946639957230* 非门（NOT）
$32191988336459* 优雅存储
$59136962133320* 逻辑引擎
$30920780473397* 循环依赖
$83321010943153* 信号计数
$58769021955965* 3 位解码器
$78673715398197* 立即数
$49679174636208* 8 位异或
$40356575891647* 8 位或
$44393538021725* 激光炮直瞄
$61228036919534* 核金汉诺塔
$87426564872318* 除法
$24593959732668* 相反数
$19487493622742* 半加器
$26705128002562* 条件判断
$94163943335575* 沙盒
$64662599400870* 1 位取反器
$14193654974055* 有符号小于
$59485174474959* 美味排序
$74096060570427* 宽指令
$14522992467987* 或门（OR）
$30630492494839* 8 位非
$11457737665157* 一把线，像挂面
$27566801288091* 元件工坊
$85514901357243* 8 位加法器
$98013649264532* 栈
$35790581910835* 第二刻
$94979277765051* 机器赛跑
$13303326918621* 与非门（NAND）
$16463062897451* 原力觉醒
$28827008935802* 实验室
$77495536880911* 或非门（NOR）
$61466151084505* 太空入侵者
$20858506932774* 与门（AND）
$92696642439976* AI 打牌
$74688348772072* 总线
$62326481348276* 迷宫
$50884376329157* 小盒子
$70651296323768* 异或门（XOR）
$31140969090253* 行星之名
$74512388889988* 算数引擎
$42873691377272* 加 5 等于几
$36114120875026* 密码锁
$45773199639367* 奇变偶不变
$68155633878444* 延迟量
$15420972347773* 随机存储器
$43018398941741* 高电平
$17198602105978* 无符号小于
$33343343932901* 图灵完备
$95989050249094* 三路与门
$81417895515868* 1 位开关
$63331549672739* 操作码
$87626070552799* 全加器
$13219675195117* 奇数个信号
$62167495140389* 移位
$28985439820134* 半字节乘法
$94896856420525* 同或门（XNOR）
$25805639594354* 程序
$57870391153000* 立即数
$96825664933181* 新品上市
$56272944092958* 延迟线
$86717899742637* 存储一字节
$53092952738479* 数据选择器
$70993791338383* 异或
$77453667419150* 指令解码器
$96898830278153* 8 位常数
$17750429607702* 1 位解码器
$59939822079116* 负数
$79570913613529* 加倍
$91267697977186* 十六进制速算
$49328023903824* 相等
$74292408260828* 计算单元
$45480765206717* 条件判断 II
$71126291573555* 成对的麻烦
$33132016601448* 压栈与弹栈
$75225719777307* 水世界
$64615090872051* 函数
$84208736840052* 时间掩码
$36221227239949* 跳舞机器
$91954159574064* 三路或门


=== components/Input16 ===

$80992639558333* 16 位输入


=== rpg/maps/overworld/chair ===

$49457747048031* 椅子
$12275727420074* 我什么都非得看一眼吗？


=== levels/test_lab ===

$46069044039152* 预期输出为 {output}（{address} 号监视态）
$11038144815919*
在这一关里，你可以利用程序对你的电路进行调试。程序运行过程中，系统可以帮你检查各个监视态的数值是否符合你的预期。

实验室为你的程序提供了 2 个额外的关键字。

关键字 [color=#c54d5e]expect[/color] 用于指定某个特定的寄存器在下一时钟刻应该存储的数值。

[color=#c54d5e]expect[/color] 后的第一个数字为要指定的监视槽号码，第二个数字为这个监视槽应该具有的期望数值。监视槽和电路中的元件需要由玩家手动链接起来，号码和链接顺序相对应。

[img]dialogue/watched_state.png[/img]

例如：
[code][color=#c54d5e]expect[/color] [color=#eb9433]2[/color] [color=#eb9433]4[/color]
[color=#4a9658]copy[/color] [color=#eb9433]4[/color] [color=#4a9658]_[/color] [color=#4a9658]r2[/color][/code]

上面的例子中，第一行的意思是，“2 号监视槽对应的元件在下一刻存储的数值应该是 4”。

电脑每运行一刻，程序都会检查是否所有的监视态都满足期望要求。如不满足，程序将会报错。程序开始运行时，所有的监视态期望值都应该为 0，期望值只有在你手动指定新值时才会改变。唯一的例外是内置的计数器，因为计数器的数值每一刻会自动增长。

实验室为你提供的第二个额外关键字是 [color=#c54d5e]set_input[/color]。利用这个关键字，你可以控制你的计算机接收到的输入：
[color=#c54d5e]set_input[/color] [color=#eb9433]123[/color]

另外，你可以通过点击下面的链接来（重新）导入测试例程：
[url=import_overture][color=#e49f44]OVERTURE[/color][/url]
$32399229965611* 另外，因为你已经完成了 [color=#e49f44]LEG[/color] 架构，我替你解锁了沙盒中的 16 位、32 位和 64 位元件。
$59234666744501* 预期线路状态为 {state}（{address} 号监视态）
$84893616447734* 第 {nr} 行：编号为 {index} 的监视槽未链接到元件上
$19965026621630* 预期输出为 {value}，但输出未启用（{address} 号监视态）
$95416257208387* 自定义元件预期状态为 {state}（{address} 号监视态）
$31718526969901* 监视态 {address} 的预期数值为 {value}
$15446846177093* 欢迎来到实验室。和元件工坊一样，这不是一个主线关卡，而是我们为你提供的工具性关卡。
$16072814175447* 在出错的硬件上编程会很麻烦。一边编程，一边还要排查电路中的错误，这种体验非常痛苦。你会忍不住去随手修复一下硬件上的问题，以便继续回头写代码。但这些硬件层面的改动很可能又会弄坏别的功能。所以在开始编程前，尽量确保你的硬件能做到 100% 可靠吧！


=== misc/run ===

$58178852564701* 运行（快捷键：F6）


=== trans/panel_console_settings ===

$57851464156855*
彩色显示模式

ASCII 码表


=== trans/panel_and ===

$48633048126675*
[right]输入 1
输入 2
输出[/right]


=== levels/byte_not ===

$14196498898485* 制造和使用工具的能力在智力的早期发展过程中起着决定性的作用。
$12982025748137* 将输入字节中的每一位逐个取反（执行逻辑非运算）。
$10294533225655* 我们先前的数学模型使用大脑体积来作为智力高低的主要判据。现在看来，这个模型还是过于简单了。
$14958585065722* 所以很显然，胳膊的数量才应该是智力的主要判据。你知道吗？地球上有种海洋生物有八条胳膊，它们在我们的测试里表现得更好。


=== trans/component_output_car_label ===


#  Label appears on the component and must be 3 letters or less
$42054040513351* CAR


=== trans/options_pan_right ===

$33884219481037* 视图右移


=== components/Maker64 ===

$17464069717985* 64 位集线器
$79677187590355* 将八根 8 位线合并为一根 64 位线


=== trans/manual_ASCII_encoding ===

$30404865580119* ASCII 码


=== rpg/maps/prison/sign3 ===

$63642446288775* 秘密实验室
$53627322304101* 告示牌


=== misc/expectations_toggle ===

$78508488734457* 开启
$97697026280362* 关闭
$58021874775869* 自动检查监视态：


=== trans/panel_outputlevel_output ===

$16896928682474* [right]输出[/right]


=== trans/not_gate_RichTextLabel2 ===

$10340875578771*
[right][color=#e49f44]输入[/color]
预期输出
当前输出[/right]


=== levels/Calculations ===

$14458828731919*
是时候把你已经做好的“算数引擎”和“寄存器之间”电路合并起来了。你设计的计算单元已被保存在了元件工坊里，随时可以作为一个元件添加到电路图之中。如果你忘了每个引脚的具体功能，可以打开元件工坊，重新确认一下电路图。

你可以用之前设计好的解码器来指定应该“计算”还是“复制”。4 种不同的工作模式复述如下：
[OFF][OFF] Immediate（立即数模式）
[OFF][ON] Calculate（算术模式）
[ON][OFF] Copy（复制模式）
[ON][ON] Condition（条件跳转模式）

在这一关里，你暂时只需要考虑复制模式和算术模式。点击工具栏中的“指令集”按钮来确认指令的格式。在算术模式下，请从 1 号寄存器（[color=#e49f44]REG 1[/color]）和 2 号寄存器（[color=#e49f44]REG 2[/color]）中读取数值作为输入的操作数，并将结果保存到 3 号寄存器（[color=#e49f44]REG 3[/color]）中。

[tip]别忘记 3 位解码器带有一个开关，可以关闭所有输出。[/tip]
$13013863429580* 这一关里，所有的寄存器都拥有一个额外的输出引脚。这个输出引脚会无视读取引脚的输入，始终输出寄存器中存储的数值。


=== trans/instructions_header ===

$15089281203426* [center]指令集[/center]


=== trans/panel_bitmemory_outputs ===

$17509974261453* 输出


=== components/Xor16 ===

$55408021160573* 对输入进行按位异或
$47846591761838* 16 位异或


=== components/LevelInput8 ===

$40943344093513* 输入


=== trans/panel_not_input ===

$96578192050623* [right]输入[/right]


=== trans/level_tick_tock_keys ===

$11700778730606*
[right][color=#e49f44]操作
预期输出
当前输出[/color][/right]


=== components/And32 ===

$98890160152994* 对输入进行按位与
$30264879217145* 32 位与


=== trans/rpg_no_signal ===

$33720960099059* 无信号


=== components/AND ===

$22719674432950*
当两路输入都为 [ON] 时输出 [ON]
[table=5]
[cell]输入 1[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]输入 2[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]输出[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell]
[/table]
$58912167455465* 与门


=== trans/panel_regred_output ===

$59910806432617* 输出


=== trans/manual_text_ascii_encoding ===

$57727768059917* 电路仿真器在一些地方使用了（扩展的）ASCII 编码。下表是各 ASCII 码及其对应的字符。控制台元件支持使用几种不同的扩展 ASCII 码表。单击手册页面右上角的选单可以在这几个不同版本间切换。


=== rpg/maps/overworld/glibob ===

$80046978163833*
找到德尔普，他很可能
在史莱姆农场
附近的草坪上
$45824943235521*
我们想炸毁飞船的
反应堆堆芯
$97390820492796*
然后把他
推上传送带
送进反应堆
$61010950688784* 你好机器人，我有一个秘密
$77669473873198* 感谢你的服务，同志
$78863196560749*
天啊，你要我
把德尔普推进那里?
$83512698380440* 我是叛军成员
$20029368257424*
堆芯只有一个弱点，
它的废料入口
$72328125758268* 听着很疯狂啊
$61319894006188*
猜对了，它叫德尔普
是只小小的蜘蛛
$88299738421104*
让我猜猜
飞船上正好有
这么个东西？
$22954462436472*
任何小到可以放进
废料口的东西都会
被立即焚烧，除非
它的绝缘性极佳
$16108649728007*
我们都要为叛军
尽己所能


=== trans/panel_fulladder_description ===

$25711866218405* [center]对 3 个输入求和[/center]


=== trans/manual_text_short_circuit ===

$31105471890701*
在电子技术中，两个元件向一条线路上同时输出不同的值会导致短路问题

[center][img=100]res://dialogue/short_circuit.png[/img][/center]

但是，通过选择性断开输出引脚与线路的连接，使得多个引脚共享一条输出数据线（即“总线”，英文称 “bus”）则是可能的。这里最重要的一点是，每个时钟刻里，至多只能有一个元件的输出与总线连通，否则仍会有短路的风险

[center][img]res://dialogue/switch.png[/img][/center]

在电路仿真器中，灰色输出引脚代表它们可以与总线断开。

（在现实电路中，元件并不会与电路真正断开连接，它们会处于被称作“高阻态”的特殊输出状态上，表现得像是与总线断开了一般。由于“高电平”[ON]、“低电平”[OFF]和“高阻态”总共是三种不同的状态，能够产生这种输出的电路被称作三态电路。本游戏中，可以控制通断的输出端口元件也被称作三态输出。——译注）


=== trans/panel_rol_output ===

$62960066333763* 输出


=== trans/manual_assembly ===

$14434902453525* 汇编


=== trans/nand_values ===

$38006065064488*
[right][color=#e49f44]输入 1
输入 2[/color]
[b]输出[/b][/right]


=== trans/complete_flower_4 ===

$86527701695205* [center]按任意键以继续[/center]


=== main_scripts/ui ===

$74397786006652* 输出
$26316545288606* 逻辑
$31787377521276* 16 位
$32778241216484* 1 位
$69169839562869* 探针
$56684378975952* 自定义
$93805543475022* 32 位
$69195385009785* 64 位
$36744990871521* 关卡
$60495775939951* IO
$49451948914812* 算数
$46598465325525* 内存
$12972244522540* 显示
$53900277352031* 8 位
$79029955304279* 输入
$77408777382636* 无缓冲引脚
$73356117817137* 三态输出引脚
$90490391067117* 沙盒


=== trans/manual_truth_tables ===

$75695254533352* 真值表


=== trans/ui_export_success ===

$97849993500646* 导出成功


=== rpg/maps/maze/door ===

$38678596054893* 门
$92590993851956* 我必须靠程序引导完成这个任务


=== levels/robot_race ===

$15403032472607* 机器人竞赛是飞船上最受欢迎的运动。不同程序控制的机器人需要完成同一组障碍赛。在完赛的程序中，谁的代码量最少，谁就是赢家。
$67151579876362*
机器人 Fastbot 的控制指令如下：
[code][color=#e49f44]0[/color] 向右一步
[color=#e49f44]1[/color] 向下一步
[color=#e49f44]2[/color] 向左一步
[color=#e49f44]3[/color] 向上一步[/code]
$19966247197959* 这次你控制的机器人叫 Fastbot，他看不到面前的东西，但它可以同时完成转身和前进的动作。另外，它还有双帅气的红色跑鞋。


=== components/DelayLine8 ===

$24840584785792* 在下一刻输出此刻的输入值
$63449911993783* 8 位延迟线


=== trans/panel_console_offset ===

$24810778105207* [right]偏移量[/right]


=== trans/panel_delayline1_input ===

$25839180359382* [right]输入[/right]


=== trans/panel_network_inputs ===

$37324411363753*
[right][color=#e49f44]命令[/color]
IP / 连接 ID
数据 / 端口
数据长度[/right]


=== trans/panel_nand_description ===

$95680138985553* [center]对两路输入进行按位与非运算[/center]


=== trans/tooltip_tooltip ===

$48829429502039*
[b]快速运行[/b]
[color=#cccccc][i]在不刷新 UI 的情况下执行指令[/i][/color]


=== rpg/maps/cave/rat ===

$86611337488971* 血
$59032985199739* 蜘蛛


=== components/Bidirectional8 ===

$20234315861487* 8 位双向端子
$49499540884410* 可以用于规避某些循环依赖的错误


=== rpg/maps/overworld/dumio ===

$90508455672478* 你真是没用
$90907400518591* 机器人，你说得对
$84369544816422*
请帮我说服
美丽的咕丽叶
与我约会
$47782962337131*
咕丽叶希望你
送她一朵粉红小花
$67886215959856*
我永远感谢
你的帮助，英雄！
$70960758502635*
哦不，我不知道
去哪里能弄到一朵
$48847456759787*
她现在应该在她的
宿舍里，你可以通过
她可爱的紫色皮肤认出她
$19291216215522* 帮帮我，机器人
$60895426154274*
好极了，你找到花了，
现在把花交给她
$28973657129570* 听起来真逊
$59402894800235* 我现在和咕丽叶约会了


=== rpg/maps/overworld/cousin_robert ===

$41316716865633* 好像是挺气人……
$86987136934243* 我是你的表哥机气人。


=== trans/splitter8_output ===

$69714402466566*
第 1 位
第 2 位
第 3 位
第 4 位
第 5 位
第 6 位
第 7 位
第 8 位


=== trans/options_reset_warning ===

$19141523477461*
该操作将删除你所有的关卡电路图、自定义元件和电脑架构图，并且无法撤销，确定要将游戏重置到出厂状态吗？
（点击下方按钮确认后，游戏将会退出。再次进入游戏时，所有内容均会被重置。）


=== dialogue/schematic_hub/order_by ===

$69981201197158* 近期热门
$70134513915163* 最新上传
$87115430626073* 我的电路
$56045953383535* 计算机架构
$25536941657464* 电路元件
$43488408276984* 最受欢迎


=== rpg/maps/overworld/chef ===

$70248641743406* 主厨
$92065398867997* 你需要帮助


=== levels/Water World ===

$13739681561355* 总量：
$19185457941725* 好消息，我们要把地球变成一个异星的水上乐园！
$18940654086036* 我们需要你帮助我们为“海盗瀑布”水滑梯找到一个合适的地点。具体地说，我们正在寻找一个能容纳大量水的地方。
$14706805272652* 按回车键显示水位
$12881972193444*
每片区域宽度为 16 列。你需要读取 16 次输入，它们按左到右的顺序对应每一列地表的海拔高度。
	
你的任务是输出这片区域所能容纳的水量上限。


=== trans/manual_de_morgan ===

$20250843622435*
四个基础逻辑门的真值表是对称的。你可以通过如下图所示的[b][color=#6e9759]对输入取反[/color][/b]（垂直箭头）或[b][color=#596197]对输出取反[/color][/b]（水平箭头）来转换它们。

[center][img=400]dialogue/manual/de_morgan.png[/img][/center]

注释
[table=2]
[cell]1 [/cell][cell]你可以在任意基础逻辑门之间彼此转换，至多需要同时对输入和输出取反[/cell]
[cell]2 [/cell][cell]你可以通过对输出取反，在或门/或非门之间进行转换。这对与门/与非门同样成立。实际上或非（NOR）的意思是“非或”（NOT OR），与非（NAND）的意思是“非与”（NOT AND）。注意，除了尖端那个意味着“非”（NOT）的小点，或门/或非门（OR/NOR）元件的形状是相似的。与门/与非门（AND/NAND）除了这个小点，其他也大致相同。[/cell]
[cell]3[/cell][cell]对输出取反，会将真值表最后一行的每一位完全反转。对输入取反，真值表最后一行则会左右翻转。[/cell]
[/table]


=== levels/delay_level_check ===

$59355217078543* 正确！
$68999077595244* 核对
$90847326020954* 不对！


=== trans/rpg_alloy_description ===

$29268002047995*
[center] [color=#eb5260]轰隆隆隆隆！[/color]

核爆炸里无人生还
[/center]


=== trans/options_color_wire ===

$64341547590822* 导线着色


=== rpg/maps/cave/door3 ===

$94313460790182* 地牢门


=== misc/credits ===

$15234594767991* 致谢


=== trans/panel_decoder3_disable ===

$50918319838744* 禁用


=== rpg/coin ===

$39259781619518* 金币


=== trans/options_music_volume ===

$93981778736076* 音乐音量


=== trans/manual_matrix_display ===

$86092436010494* 点阵显示屏


=== trans/level_alu2_code ===

$93157894815498* OR


=== misc/binary_submit ===

$95509904060545* 提交


=== components/ByteConstant ===

$29445030761909* 输出一个常数
$25159790815891* 8 位常量


=== components/Maker16 ===

$55864807379312* 将两根 8 位线合并为一根 16 位线
$39941195789458* 16 位集线器


=== components/Output64 ===

$77952953696011* 64 位输出


=== components/Switch16 ===

$15221175893882* 16 位开关
$59845475842015* 切换线路通断


=== trans/share_prompt_bbcode_tags ===

$51065735869890*
支持的 BBcode 标签：
URL：[url]https://turingcomplete.game[/url]
等宽字符（代码域）：[code]01011101[/code]


=== rpg/maps/prison/rat ===

$68894472933139* 叽叽吱吱
$86305699756314* 血
$30670667527598* 老鼠


=== levels/sandbox ===

$17054292175058* 欢迎来到沙盒，在这里你可以自由发挥。我给了你 64 位线和一些 IO 组件。
$10731996208080* 也给了你 64 位版本的程序、计数器、寄存器和内存元件。但请注意，64 位的内存需要花费 1 个时钟刻才能完成读取。
$72764802067974*
欢迎来到沙盒模式。 

组件被统一放在右侧的菜单中，你可以将它们摆放在电路图上。摆放好后，点击元件的引脚并拖动，便可用导线连接它们。窗口左侧的面板为你提供了一些用于模拟控制的工具。请留意，用鼠标右键单击“快速运行”按钮，即可设置快速运行的速度上限。（此处设定值为理论上限，实际速度取决于电路复杂度与电脑配置。——译注）

你可以在手册中找到更多关于电路模拟器的信息（手册按钮在左上方工具栏中）。记得充分利用我们为你提供的程序元件（允许你自行编写汇编程序）和辅助关卡“元件工坊”（允许你创建自定义元件）。此外，沙盒模式拥有几种专属元件，这些元件在“IO”菜单下的“沙盒”子菜单中。
$19454393978813* 键盘元件能让你直接控制你的电脑，使用你的……键盘。
$14434122873489* 声音元件能让你制造点噪音。把这玩意交给你，我以后可能会后悔。
$18405942066048* 系统时间元件为你提供当前的 UNIX 时间，单位为微秒。
$10451578314373* 控制台元件允许你在屏幕上输出字符（关于 ASCII 字符，参见手册）。


=== trans/level_complete_stat_type ===

$69511102367948* 关卡类型


=== trans/panel_or_input ===

$70466834507347*
[right]输入 1
输入 2[/right]


=== misc/onwards ===

$51096427131653* 继续


=== trans/manual_recipe_Label ===

$30773017984502*
多数[color=#dd6576][url=Circular dependency]循环依赖[/url][/color]是由错误的设计引入的，它们混乱且无益。但少数特殊设计的循环依赖电路能够派上特别的用场。如果在游戏设置中启用了循环依赖白名单，则电路仿真器将允许三种特殊的循环依赖电路存在。这些电路连线会被高亮显示。

[b]或非门（NOR）锁存器[/b]
或非门锁存器能存储 1 位数据，这一位数据可从线路 [b]Q[/b] 上读出。
[center]
[table=3]
[cell]   [b]S[/b]  [/cell][cell]       [b]R[/b]     [/cell][cell]操作结果[/cell]
[cell]  [img]dialogue/off.png[/img][/cell][cell] [img]dialogue/off.png[/img][/cell][cell]无任何效果[/cell]
[cell]  [img]dialogue/off.png[/img][/cell][cell] [img]dialogue/on.png[/img][/cell][cell]写入值变为 [img]dialogue/off.png[/img][/cell]
[cell]  [img]dialogue/on.png[/img][/cell][cell] [img]dialogue/off.png[/img][/cell][cell]写入值变为 [img]dialogue/on.png[/img][/cell]
[cell]  [img]dialogue/on.png[/img][/cell][cell] [img]dialogue/on.png[/img][/cell][cell]错误[/cell]
[/table]                    [img=150]dialogue/manual/circular_recipes/nor_latch.png[/img]
[/center]

[b]与非门（NAND）锁存器[/b]
与非门锁存器能存储 1 位数据，这一位数据可从线路 [b]Q[/b] 上读出。
[center]
[table=3]
[cell]   [b]S[/b]  [/cell][cell]     [b]R[/b]     [/cell][cell]操作结果[/cell]
[cell]  [img]dialogue/off.png[/img][/cell][cell] [img]dialogue/off.png[/img][/cell][cell]错误[/cell]
[cell]  [img]dialogue/off.png[/img][/cell][cell] [img]dialogue/on.png[/img][/cell][cell]写入值变为 [img]dialogue/off.png[/img][/cell]
[cell]  [img]dialogue/on.png[/img][/cell][cell] [img]dialogue/off.png[/img][/cell][cell]写入值变为 [img]dialogue/on.png[/img][/cell]
[cell]  [img]dialogue/on.png[/img][/cell][cell] [img]dialogue/on.png[/img][/cell][cell]无任何效果[/cell]
[/table]                    [img=150]dialogue/manual/circular_recipes/nand_latch.png[/img]
[/center]

[b]与（AND）或（OR）锁存器[/b]
与或锁存器能存储 1 位数据，这一位数据可从线路 [b]Q[/b] 上读出。
[center]
[table=3]
[cell]   [b]H[/b]  [/cell][cell]     [b]R[/b]     [/cell][cell]操作结果[/cell]
[cell]  [img]dialogue/off.png[/img][/cell][cell] [img]dialogue/off.png[/img][/cell][cell]写入值变为 [img]dialogue/off.png[/img][/cell]
[cell]  [img]dialogue/off.png[/img][/cell][cell] [img]dialogue/on.png[/img][/cell][cell]错误[/cell]
[cell]  [img]dialogue/on.png[/img][/cell][cell] [img]dialogue/off.png[/img][/cell][cell]无任何效果[/cell]
[cell]  [img]dialogue/on.png[/img][/cell][cell] [img]dialogue/on.png[/img][/cell][cell]写入值变为 [img]dialogue/on.png[/img][/cell]
[/table]                    [img=150]dialogue/manual/circular_recipes/and_or_latch.png[/img]
[/center]


=== trans/panel_equal_description ===

$66334667083051* [center]判断表达式（输入 1 = 输入 2）是否成立[/center]


=== levels/byte_less ===

$11252365204151* 搭建一个电路，当第一路输入严格小于第二路输入时，输出 [ON]。注意，在本关中，输入应被视作[color=#dd6576]无符号整数[/color]。
$62766453128684* {a} 小于 {b} 吗？
$11632471752785* [center]判断第一个输入是否严格小于第二个。[/center]


=== levels/Logic Engine ===

$38905765358316* 操作码
$17594613477534*
创建一个可以对两路输入进行按位或（OR）、按位与非（NAND）、按位或非（NOR）以及按位与（AND）运算的设备。第三路输入是一个[INSTRUCTION]。[INSTRUCTION]是一个数字，它用于指示我们要进行什么样的运算。

本关涉及到的指令列表如下：
[code][color=#87a8c8]0 OR（或）
1 NAND（与非）
2 NOR（或非）
3 AND（与）[/color][/code]

另外，在这一关中你不能移动红色组件，原因将在以后揭晓。
$74299241677249* 输入 1
$60407971040713* 输入 2


=== trans/hub_order_by ===

$83319579232915* 排列顺序


=== trans/level_byte_less_i_description ===

$21195810950441* [center]判断第一个输入是否严格小于第二个。[/center]


=== trans/component_panel_latency_RichTextLabel2 ===

$51386316768363*
等待响应
输出 1
输出 2
输出 3
输出 4


=== components/Splitter64 ===

$80420054807186* 将一根 64 位线拆分为八根 8 位线
$14205692632393* 64 位分线器


=== misc/component_button ===

$75542474510177* 门数量
$20148770258379* 【不可用】元件面积为零
$53184531022842* 【不可用】沙盒模式专属
$40492377880609* 【不可用】引脚重叠
$63839315669055* 总延迟


=== trans/panel_index_bit_index ===

$96885367697181* [right]索引值[/right]


=== trans/panel_divmod_input ===

$48801764966719*
[right]被除数
除数[/right]


=== components/Output 3 ===

$96269858195218* 输出


=== components/Output 1B ===

$15931283897895* 8 位输出


=== components/Xor64 ===

$95012060885697* 64 位异或
$13031452187028* 对输入进行按位异或


=== trans/panel_output_output_1 ===

$38712851498419* 输出 2


=== misc/skipped_custom ===

$38174137226538* 选择元件

#  This is the text on a button that appears when a custom component has changed size and no longer fits in a schematic. You can press this button to make the camera go to the location where the custom component was
$99860977387728* 转到具体位置


=== components/ByteXor ===

$98219910712564* 8 位异或
$83236921580268* 对输入进行按位异或


=== trans/panel_counter16_output ===

$13295622648285* 输出


=== levels/Spacial Invasion ===

$19967210826470* 注意，上一束激光仍在空中飞行时，机器人是无法发射新的激光的。
$16294185981398* 我们飞船的货仓里了进了几只太空老鼠。
$11505369795084* 如果你想知道如何为机器人编程，请参阅[color=#e49f44][url=the_robot]机器人操作指南[/url][/color]。代码编辑器里也有指向该手册词条的链接。
$10515630949378* 我们已将你的计算机连接到了我们的高科技机器人上，你的任务是给机器人编程，让它发射激光来清除太空老鼠。


=== components/Nand8 ===

$50859914201083* 对输入进行按位与非
$93314093190526* 8 位与非


=== components/Add64 ===

$14174811828377* 对两路输入求和
$73418471595285* 64 位加法器


=== main_scripts/leg_level ===

$70383685548547* REG {nr}
$20104629254326* 参数 2
$65642901654732* {component} 应处于禁用状态
$98778676892898* {component} 应处于启用状态，且具有数值 {value}
$14186606871089* 下一时钟刻，计数器的数值将是 {wrong_value} ，但正确值应为 {value}
$38681417496680* 参数 1
$27868897434461* 未找到计数器元件
$37810243909140* 计数器
$50722296752142* 输入
$43723329256095* REG {nr}
$24003300271049* {component} 中的数值应为 {value}，而不是 {wrong_value}。
$60997201855346* 结果地址
$50231510806554* 未找到程序元件
$49810487048038* 计数器
$18236360532765* 输出
$84307766381146* 操作码
$20950946171790* 跳转到


=== levels/call_ret ===

$15840165316981*
这一关里，你的任务是向你的电脑里添加负责函数调用和返回的指令：[color=#e49f44]call[/color] 和 [color=#e49f44]ret[/color] 。

注意，当你从子函数返回调用点时，返回的位置应该在 [color=#e49f44]call[/color] 指令的下一行，否则你的程序会进入死循环。
函数调用指令 [color=#e49f44]call[/color] 对应的具体操作如下：
 [i]- 将程序计数器的值和指令长度相加，并将其[color=#e49f44]压入[/color]栈顶[/i]
 [i]- 令程序计数器跳转到函数入口处[/i]

函数返回指令 [color=#e49f44]ret[/color] 对应的具体操作如下：
 [i]- [color=#e49f44]弹出[/color]栈顶值，并将其写入程序计数器[/i]

你可以将某些数据写入寄存器中，从而向函数传递信息，或让函数返回计算结果。如果采取这种传参方式，就请特别留意子函数运行过程中到底会改写哪些寄存器。
$19416009887091*
有些时候，重复利用某段代码能够简化编程流程。这些需要重用的代码可以单独写成几段“函数”。要重用这些代码片段，我们就需要让代码能够[color=#e63e5b][url=terminology]跳转[/url][/color]这些函数的开头，等代码执行到函数结尾时再跳转回来。我们把跳转到函数开头的操作称为函数的[color=#e49f44]调用[/color]（[color=#e49f44]call[/color]），从函数结尾处跳转回来的操作则称作函数[color=#e49f44]返回[/color]”（[color=#e49f44]return[/color]）。
	
不过，要想真正实现代码重用，就要解决一个问题：返回跳转操作如何才能跳转到子函数调用点处（一个函数可以多处地方被调用，因而可以对应多个不同的返回地址）。

一种思路是在跳转前把程序计数器的值存入寄存器中，这样就能让记录函数返回位置。不过这种思路的问题在于，函数调用无法嵌套执行，因为进行下一次调用时，第一次保存的返回地址就会被覆盖掉。

比如，我们需要让函数 A 调用函数 B，而 B 又调用了函数 C 。当我们需要从函数 C 返回 B 时，我们需要 B 中的返回地址；而 B 返回时，我们又需要 A 中的返回地址。一般来说，不管我们调用何种函数，也不管它们在代码中的具体顺序如何，我们最后记录的返回地址总会是最先用到的。这种“后进先出”的需求恰好对应了栈的工作模式。
$19369640789869* 我们最近的经费预算有点紧张，只能给大家降薪，结果现在实验室的助手们都罢工了。所以，这一关卡里你需要亲自评估设计的成果。当然，这也能让我们测试你的可信度和成熟度。
$15463931654475* [center]向电脑中添加“call”和“ret”指令，并实现对应的功能[/center]


=== misc/ProbeWireBit ===

$49521764791439* 线路探针（1 位）
$15206117280094* 可将自定义元件中某条线路的值显示在其表面，或链接到程序编辑器的监视槽上


=== trans/manual_computer_concepts ===

$60892983318818* 计算机术语


=== components/ByteShr ===

$89595863403484* 8 位右移器
$69394421220436* 对输入进行按位右移


=== rpg/maps/overworld/monklaar ===

$78391472992197* 我喜欢食堂的新水果！


=== trans/level_sr_latch_RichTextLabel3 ===

$55348415524361*
[right]输入 1
输入 2
预期输出
当前输出[/right]


=== components/Ashr64 ===

$26454447445967* 将输入的数值按位右移，并保持符号不变
$91080427115081* 64 位算术右移器


=== components/LessU64 ===

$13018528868948* 小于 (无符号)
$90244529484227* 判断输入 1 是否严格小于输入 2


=== trans/panel_regredplus_output ===

$33621557361089*
读取时输出
始终输出


=== trans/panel_shr_input ===

$98628213136355*
[right]输入
右移量[/right]


=== trans/level_byte_no_description ===

$19806403089477* [center]将输入的每一位逐个反转[/center]


=== rpg/maps/prison/human ===

$26878139502295* 玩家躺在这里
$55952257027183* 人类
$15754158619172* 血
$46356151087784* 我是玩家


=== levels/call_ret/completed ===

$65495857744236* 我已完成该关卡
$82323203550887* 我们能相信你吗？


=== components/LessU16 ===

$91783087669146* 判断输入 1 是否严格小于输入 2
$33190791348214* 16 位小于比较器（无符号）


=== components/Xor32 ===

$66299093873977* 32位异或
$38169019785615* 对输入进行按位异或


=== trans/manual_text_instructions ===

$24791538034329*
这个游戏里的“指令”也叫“操作”或“操作码”（OPCode，operation code）。无论对什么操作系统或编程语言（或其他在这之上的层级）而言，所有的软件都不可避免地要被最终还原为可供 CPU 直接使用的一系列操作指令。

在现代 CPU 内部，指令会被进一步翻译为程序员无法触及的、步骤更细致的“微码”（microcodes）。


=== trans/level_turing_complete_description ===

$74859324795927* [center]在计算功能的基础上，添加条件跳转功能[/center]


=== trans/level_nand_check ===

$61241226128494* 不对！
$32982011047799* 核对


=== trans/level_complete_tooltip ===

$33922330743421*
[b]导线颜色[/b]
[color=#cccccc][i]用不同的颜色使你的导线整齐有序[/i][/color]


=== rpg/maps/overworld/knight ===

$97019929955594* 前方禁止通行
$86067786292380* 我这就走......


=== trans/level_odd_number_RichTextLabel2 ===

$28592851869484*
[right][color=#e49f44]输入 1
输入 2
输入 3
输入 4[/color]
预期输出
当前输出[/right]


=== trans/level_complete_robot ===

$73150174144736*
[b]机器人 Robotron 9000+[/b]
[color=#cccccc][i]使用计算机控制 [color=#e49f44]Robotron 9000+[/color][/i][/color]


=== trans/panel_matrix_color ===

$78812572100236* [center]像素 / 刷新[/center]


=== components/LessI64 ===

$42718501644862* 64 位小于比较器（有符号）
$19948786194409* 判断输入 1 是否严格小于输入 2


=== components/ByteLessU ===

$68645721548287* 判断输入 1 是否严格小于输入 2
$73502755965496* 8 位小于比较器（无符号）


=== ui/global_translations ===

$85913831661289* IF_LESS
$69956969985790* ORi

#  Instead of writing 5839000, the number turns into 5.8M
$22896492410578* M
$11144256835662* XORi

#  4 letters max
$61412773713567* SUB
$53021804895845* ANDi
$52344899983501* IF_LESS_OR_EQUAL
$89945092889418* SUBi

#  4 letters max
$89011349770597* NOT
$18868256335352* 检测到循环依赖：元件的输出连接到了自身的输入上。点击[url=page~Circular dependency]此处[/url]查看相关说明
$71559031724238* IF_NOT_EQUAL
$29718660090112* 答案错误

#  4 letters max
$40520283279584* XOR
$12671132029272* 该电路已经保存到元件工坊。
$71204580217527* NOTi
$71195301111400* ADDi
$98178474649432* IF_GREATER_OR_EQUAL
$68187490877029* IF_EQUAL

#  4 letters max
$44009845985661* ADD

#  4 letters max
$68666991962246* OR
$44906330481241* 总延迟
$45532697833519* 你达到了第 {level} 级！
$30602804398798* 门数量

#  4 letters max
$33873219185286* NAND

#  Instead of writing 5839, the number turns into 5.8K
$84696693690500* K
$79492115258673* IF_GREATER

#  4 letters max
$64519909700148* AND
$76763908762578* 时钟刻

#  4 letters max
$36090730285143* NOR
$37093663674348* 第 {x} 级

#  Instead of writing 5839000000, the number turns into 5.8B
$71072134093858* B


=== trans/panel_decoder2_description ===

$29468245669811* [center]根据输入值，选择一路输出将其激活（输出高电平）[/center]


=== components/Shl16 ===

$79406691850426* 16 位左移器
$34287811246049* 对输入进行按位左移


=== trans/level_division_headers2 ===

$43313037226215* 余数


=== trans/levels_any_doubles_RichTextLabel2 ===

$60287131882436*
[right]输入 1
输入 2
输入 3
输入 4[color=#e49f44]
预期输出
当前输出[/color][/right]


=== trans/schematics_menu_visible_label ===

$34084132835354* 在元件菜单中显示


=== components/RegisterRedPlus ===

$57531353625235* 8 位寄存器


=== trans/level_saving_bytes_text ===

$43691912945654*
[right]操作
预期存储值
预期输出
[/right]


=== trans/panel_input_input_2 ===

$13656747150138* 输入 3


=== components/Counter64 ===

$62528867413395* 64 位计数器
$62736827510023* 除非被复写，否则每一刻存储值自动增加


=== main_scripts/rpg ===

$87641351044559* 空
$13202063774683* 墙
$57777174895519* 墙
$14021436258446* 前方：[color=#e49f44]{looking_at}[/color]
$25433644956674* 死于 {who}
$64739179991428* 机器人死了！


=== misc/add_assembly ===

$66747898777348* 添加


=== trans/level_nand_1 ===

$71204033550134* 电路中的与非门有什么效果？


=== rpg/maps/prison/exit_door ===

$92379689291727* 门


=== trans/overwrite_button ===

$11839708860574* 覆盖


=== misc/rom_file_select_button ===

$46471024006274* 设置默认文件


=== rpg/maps/overworld/bush ===

$37683898820147* 这是灌木丛
$93113262859645* 灌木丛


=== trans/manual_text_program ===

$25326551844839*
程序元件是一个只读存储器元件，但特别之处在于你可以用汇编代码改写其中的数据。点击元件右上角的黄色按钮，即可编辑元件中存储的代码。

[center][img]dialogue/manual/program_edit.png[/img][/center]

屏幕中央是代码编辑器，点击[color=#4d82c5][url=Assembly]此处[/url][/color]了解更多关于汇编代码的细节。

位于代码编辑器左侧的是汇编别名，你可以在此处定义别名（助记符）。在编辑器中，别名能够取代对应的数字操作码。与其记住哪个数字对应您的体系中的 AND 指令，你可以直接在你的汇编代码中使用“AND”，改善代码的可读性，使代码更易于阅读和维护。

[center][img]dialogue/manual/assembly_codes.png[/img][/center]

在程序元件上，你还可以看到“编辑监视态”按钮。

[center][img]dialogue/manual/watch_state.png[/img][/center]

这个功能可以可让你将代码编辑器链接到到寄存器、计数器或探针上。这样，你就可以在编写代码时检查架构中的存储器状态，而无需关闭编辑器。


=== components/Output32z ===

$20432213737411* 32 位三态输出
$73681609562628* 只在开关引脚为 [ON] 时输出，否则不输出


=== trans/level_negative_Label ===

$11951041502381* 填入不同的数字来改变每一位对应的数值。


=== trans/level_byte_equal_description ===

$38686097566531* [center]检查输入的两个单字节数值是否相等[/center]


=== components/Xnor ===

$94079327237795* 同或门
$90614106399129*
当两路输入相同时为 [ON]
[table=5]
[cell]输入 1[/cell][cell][OFF][/cell][cell][ON][/cell][cell][OFF][/cell][cell][ON][/cell]
[cell]输入 2[/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell][cell][ON][/cell]
[cell]输出[/cell][cell][ON][/cell][cell][OFF][/cell][cell][OFF][/cell][cell][ON][/cell]
[/table]


=== components/Not16 ===

$17394768116288* 16 位非
$91053300263019* 对输入进行按位非（按位取反）


=== trans/level_complete_manual_page ===

$39011561067359* [b]手册词条[/b]


=== trans/panel_sound_command ===

$66510191984141* 命令


=== trans/panel_input_up ===

$97169317610794* 上


=== trans/manual_network ===

$67416967652082* 网络


=== component_panels/SpriteDisplay ===

$94199633210330* 未选择文件


=== trans/level_complete_stat_level ===


# [color=#cccccc][i]RTFM[/i][/color]Entry: [color=#68d277]Architectural complexity[/color]
$92313038380926* 关卡


=== trans/ticks_sec ===

$16026817441460* 刻/秒


=== rpg/maps/boss_room/tricky ===

$36278362971660* 不！不！不！
$48425443153584* 可恶 可恶 可恶
$83674875280936* 别害羞啊
$55557864347967* 呸呸呸
$46678960551148* 不 不 不
$34049297531488* 来啊 来啊
$45293657348934* 哈哈哈哈哈
$44499633447481* 我等不及了
$62754542093871* 射啊 射啊 射啊
$45196756331738* 小鬼
$96717076976482* 站住，箱子是我的
$39217019822298* 叽叽叽叽叽
$83023298467462* 叽叽叽叽
$54218005116072* 坏 坏 坏
$88481545304668* 叽——
$83172011939489* 吓坏了吧
$58217446676216* 安息吧，小鬼


=== ui/top_bar/gate_score ===

$16224450605442* 门数量：


=== misc/score_sync ===

$76911045833478* 同步


=== components/ON ===

$96212935718484* 始终输出 [ON]
$95896157427528* 高电平


=== trans/panel_or_output ===

$68791649314727* 输出


=== trans/panel_shr_output ===

$53187359961794* 输出


=== trans/options_setting_program_alignment ===

$54874717650167* 启用程序计数器对齐检查


=== trans/xor_gate_RichTextLabel2 ===

$21417732641222*
[right][color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出[/right]


=== trans/share_prompt_label ===

$61304386273201*
名称
描述


=== components/RegisterRed ===

$10081371413873* 8 位寄存器


=== trans/delete_confirm ===

$57294448765637*
确定要删除
这个电路图吗？
$74657548486940* 确认


=== levels/saving_gracefully ===

$14295883660596* 待写入的值
$14950983012226* 写入
$14837033157870* 操作
$12474728041023*
延迟线允许我们将一个输入值暂存 1 刻。不过一个能将输入值保存更长时间的元件会更有用。

我们希望你能搭建这么一个元件。
$13045361823397* 不写入
$13740696609075*
本关有两个输入。
第一个输入为 [ON] 时，你需要用新的数据覆盖已存储的数据。
第二个输入端的数值是需要写入的数据。
输出端需要始终输出当前存储器内存储的数值。
这个元件的示意图如下：

[img]dialogue/saving_gracefully/bit_memory_zh_CN.png[/img]


如果你卡关了，可以参看这个[color=#e63e5b][url=saving_gracefully]提示[/url][/color]。


=== ui/files_export_description ===

$78500352397752*
[b]导出选项[/b]

 导出格式：

 生成构建脚本：

 开启优化：

 导出路径：


=== trans/rpg_hats_exit ===

$71200030457801* 退出


=== trans/level_unseen_fruit_description ===

$96313037592447* [center]使用机器人检测传送带上的水果，并完成关卡要求[/center]


=== trans/panel_keyboard_character_mode ===

$98676883649624* [right]字符模式（输出 ASCII 值）[/right]


=== ui/file_export_button ===

$35572795990520* 导出


=== trans/panel_divmod_output ===

$94866933026297*
商
余数


=== trans/instructions_the_robot ===

$26358418182667*
[color=#e49f44]0[/color] 原地左转
[color=#e49f44]1[/color] 前进一格
[color=#e49f44]2[/color] 原地右转
[color=#e49f44]3[/color] 原地发呆（跳过一回合）
[color=#e49f44]4[/color] 与面前的物体交互[color=#a9a9a9]（ENTER 键）[/color]
[color=#e49f44]5[/color] 发射激光[color=#a9a9a9]（TAB 键）[/color]


=== trans/nor_gate_RichTextLabel2 ===

$52955821161579*
[right][color=#e49f44]输入 1
输入 2[/color]
预期输出
当前输出[/right]


=== trans/manual_text_edit_instructions ===

$75786562031150*
在你完成“图灵完备”这一关后，游戏将允许你在指令面板中手动定义指令。点击上方工具栏中的齿轮图标可以打开指令面板。如果你打算建造自己的计算机，那么定义自己的指令集会为你带来不少便利。

如果你刚完成 OVERTURE 计算机，然后发现有些指令没有按照预想中那样运转，那么很有可能是你改变了指令的定义。

你可以自己定义不同的指令。点击指令面板的下拉箭头，你将会看到当前指令集中所有指令的具体定义。单击列表最下方的绿色加号，你可以新建一条指令说明。每一行指令说明包含 1 个标签和 8 个位，其中每个位可以被设置为[img]dialogue/on.png[/img]、[img]dialogue/off.png[/img]或者[img]dialogue/any.png[/img]（通配符）。当使用指令面板时，如果各个数据位的排列方式与下方列表中的某一行相匹配，则与这一行规则对应的标签就会在上方亮起，为你提示这条指令的具体功能。

（指令面板只是一个助记工具，在指令面板中进行编辑不会影响电路的任何实际功能。指令具体功能仍然需要通过正确的电路设计来实现。——译注）


=== components/Rol32 ===

$88734684504266* 对输入执行按位循环左移
$83642246004160* 32 位循环左移器


=== trans/panel_add_input ===

$43784903785964*
[right]输入进位
输入 1
输入 2[/right]


=== trans/panel_mux_description ===

$30551449512908* [center]从输入 1 和输入 2 中选取一个输出[/center]


=== trans/options_code_font_size ===

$98135524286922* 代码字号


=== trans/rpg_complete_derpootext6 ===

$29750433345543* [center]你怎能如此残忍？[/center]


=== trans/panel_less_u_output ===

$19353239892904* 输出


=== trans/panel_sum_output_0 ===

$54481599074471* 总和


=== levels/binary_start ===

$19099025738142* 开始


=== ui/file_export ===

$80702678699819* 导出


=== rpg/maps/boss_room/abyss ===

$75322073059042* 深渊


=== rpg/maps/overworld/flower ===

$72524391591873* 花 


=== trans/panel_counter8_output ===

$35643379690712* 输出


=== components/Input1_1B ===

$10517158300617* 关卡输入
$57868504368581* 读取关卡的测试样例输入


=== trans/manual_text_network ===

$70445160410129*
[b]概述[/b]
“网络”元件为你提供了底层的网络访问功能。一般来说，如果想操纵网络连接，你需要先向这个组件发送命令（[color=#e49f44]Commands[/color]），然后等待它和网络上的其他机器处理你的请求。远程计算机返回信息后，该元件会将更新事件（[color=#39aa49]Events[/color]）加入到一个队列中，你需要对这些事件逐个进行处理。为了同时处理多个不同的连接，你需要用每个远程目标唯一对应的连接编号（[color=#dd6576]Connection ID[/color]）来指定每次操作的目标。

下方列出的是你可以发送给组件的具体命令类型，以及它们的参数：
[table=2]
[cell][code]0[/code][/cell] [cell]No command[/cell]
[cell][/cell][cell][i]无操作[/i][/cell]
[cell][code]1[/code][/cell] [cell][color=#e49f44]Listen[/color] ([color=#dd6576]Port[/color])[/cell]
[cell][/cell][cell][i]监听 Port 参数指定的端口（用于服务端）[/i][/cell]
[cell][code]2[/code][/cell] [cell][color=#e49f44]Connect[/color] ([color=#dd6576]IP[/color], [color=#dd6576]Port[/color])[/cell]
[cell][/cell][cell][i]与目标 IP 地址对应的端口建立连接（用于客户端）[/i][/cell]
[cell][code]3[/code][/cell] [cell][color=#e49f44]Send data[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Data[/color], [color=#dd6576]Data length[/color])[/cell]
[cell][/cell][cell][i]向 Connection ID 指定的连接目标发送 1~8 字节数据[/i][/cell]
[cell][code]4[/code][/cell] [cell][color=#e49f44]Close[/color] ([color=#dd6576]Connection ID[/color])[/cell]
[cell][/cell][cell][i]关闭指定的网络连接[/i][/cell]
[cell][code]5[/code][/cell] [cell][color=#e49f44]Read next event[/color][/cell]
[cell][/cell][cell][i]读取返回队列中的下一个事件[/i][/cell]
[/table]
[i]请查看组件面板，以了解哪个引脚对应哪个参数。[/i]

收到监听命令与连接命令（[color=#e49f44]Listen[/color] 和 [color=#e49f44]Connect[/color]）后，网络组件将输出新建连接的编号（[color=#dd6576]Connection ID[/color]）。

要在两个程序之间通过网络发送数据（[color=#e49f44]Send data[/color]），两者之间必须先建立连接。要建立连接，其中一个程序（称为服务端）必须首先选择一个端口（[color=#dd6576]Port[/color]）进行监听（[color=#e49f44]Listen[/color]）。另一个程序（称为客户端）则必须连接（[color=#e49f44]Connect[/color]）到对应的 [color=#dd6576]IP[/color] 地址和端口（[color=#dd6576]Port[/color]）上。建立连接以后，服务端和客户端的后续操作就没有差别了。

请注意 [color=#dd6576]IP[/color] 地址是一个 32 位的数字，通常由四个 0~255 的十进制数字组成，并以点分隔（例如：127.0.0.1）。在电路仿真器里向网络元件输入 IP 地址时，你需要把这四个字节的顺序颠倒过来，所以 127.0.0.1 需要写为 0x0100007F。本手册页面右上角为你提供了一个在十进制 IP 地址与对应的 32 位编码间快速转换的小工具。0x0100007F 是你的计算机本地环回地址，你可以使用它来连接该游戏所处的这台计算机上的任何程序。

你可以通过检查“下一个事件”引脚的输出，来检测网络上何时发生事件，及具体的事件类型。以下是所有事件类型的列表：
[table=2]
[cell][code]0[/code][/cell][cell]No event[/cell]
[cell][/cell][cell][i]无事件[/i][/cell]
[cell][code]1[/code][/cell][cell][color=#39aa49]Incoming connection[/color] ([color=#dd6576]Connection ID[/color], [color=#dd6576]Port[/color])[/cell]
[cell][/cell][cell][i]监听到 Connection ID 上的连接请求（服务端事件）[/i][/cell]
[cell][code]2[/code][/cell][cell][color=#39aa49]Connect complete[/color][/cell]
[cell][/cell][cell][i]连接已建立（客户端事件）[/i][/cell]
[cell][code]3[/code][/cell][cell][color=#39aa49]Receive data[/color] ([color=#dd6576]Connection ID, Data[/color], [color=#dd6576]Data length[/color])[/cell]
[cell][/cell][cell][i]自 Connection ID 对应的连接处接收到数据[/i][/cell]
[cell][code]4[/code][/cell][cell][color=#39aa49]Connection closed[/color] ([color=#dd6576]Connection ID[/color] / [color=#dd6576]Error code[/color])[/cell]
[cell][/cell][cell][i]连接已关闭[/i][/cell]
[/table]

连接请求（[color=#39aa49]Incoming connection[/color]）事件仅在监听（[color=#e49f44]Listen[/color] ）操作之后产生。使用不同的端口（[color=#dd6576]Port[/color]） 来区分不同的监听者（不同的监听者不能同时监听同一个端口）。

连接已建立（[color=#39aa49]Connect complete[/color]）事件仅在连接（[color=#e49f44]Connect[/color]）操作之后产生，它代表连接准备工作已经就绪。在正式发送数据之前，请确保接收到了这个讯息。

你可以一次发送或接收 1 到 8 个字节的数据，具体长度须通过参数 [color=#dd6576]Data length[/color] 指定。

一个连接所处的状态可以是“可能打开”或“关闭”。除非你真正地发送数据，否则没有办法确定一个连接是否真的处于打开状态。这是底层网络协议的刻意设计，用以保证网络可靠性和速度，并非本游戏设下的的限制。

如果你得到的连接编号（[color=#dd6576]Connection ID[/color]）值为 -1，意味着连接出错了。


=== trans/level_negative_Label2 ===

$39515538046175* 单击切换各数位的状态以观察结果


=== ui/toggles/negative_numbers ===

$50924073287410* 切换数字格式


=== trans/levels_description ===

$33755630709299* 击败 NAK 02 ，拯救世界


=== misc/factory_back_inner ===

$12211557416281* 返回


=== trans/panel_rom_inputs ===

$52400325164412*
[right]读取
[i][color=#aaaaaa]（仅沙盒模式可用）[/color][/i]写入
地址
待写入数值[/right]


=== components/ByteShl ===

$74488427658653* 8 位左移器
$66482114876737* 对输入进行按位左移


=== components/Add16 ===

$28092601427278* 对两路输入求和
$30820974870562* 16 位加法器


=== trans/schematics_description ===

$39347262933523* 描述


=== components/Not32 ===

$33620523355085* 32 位非
$24607331341411* 对输入进行按位非（按位取反）


=== components/MemoryProbe ===

$46948613505134* 可将自定义元件中存储的某个值显示在其表面，或链接到程序编辑器的监视槽上
$44867305035474* 存储器探针


=== trans/nand_Label ===

$11482037025960*
输入 1


输入 2


=== components/LevelOutput8 ===

$77044600156969* 输出


=== trans/level_turing_complete_text ===

$83740652063566*
指令
输入


=== misc/StateProbe ===

$54427436420428* 线路探针
$15969687819995* 可将自定义元件中某条线路的值显示在其表面，或链接到程序编辑器的监视槽上


=== trans/manual_text_rgb ===

$52915933943906*
游戏中部分元件使用 3 字节的数据来显示 RGB 真彩色。红、绿、蓝三个通道各使用一个字节（8 位）的整数来指定该通道的亮度，取值范围为0~255：
[color=#e3243f]RRRRRRRR[/color][color=#55ff55]GGGGGGGG[/color][color=#3333ff]BBBBBBBB[/color]


=== levels/sr_latch ===

$11150103897185* 在这一关中，元件的输出可以依赖自己的输入，或形成最多两个元件的环路。对某些输入来说，尽管依赖于自己的输出，但其中一些导线上依然可以有稳定的输出。
$15754153332116* 本关介绍了锁存的概念。这个机制不是完成游戏的必要条件。

# The circuit you are asked to construct here has a circular dependency. The circuit also has 2 "stable states" for most inputs. A stable state here means that every component's output agrees with its input. As an example, an OR gate with one input disconnected and the other connected to its own output is stable. If the output is [OFF], both inputs are [OFF], which agrees with the OR gate. If the output is [ON], then so is one of the inputs. However, a NOT gate connected to its own input is not stable. If the output is [ON], then the input is [ON] as well. This will cause the NOT gate to try and make the output [OFF], which will also make the input [OFF]. The circuit will switch between these two states forever, so it is not stable.
$18165461234561* 延迟线的概念很容易理解，也可以用于构建任何计算机架构。然而，现代硬件不再使用这些作为内存的基础。
$15213907597666* 用 2 个或非门（NOR），建立与真值表相匹配的电路。你需要构建一个互锁的电路才完成这一点。
$19448398663695* 当我们想确定在一个循环依赖的关系中的哪些元件在输出信号时，会发现我们无法追溯到信号的来源。因此，我们使用上一时刻导线的状态来作为信号的来源。这样做是有据可循的：在真实的硬件中，电子并不是即时移动的。根据不同的电路，导线要么不停地在 [ON] 和 [OFF] 之间跳动，要么停留在一个稳定的状态下。


=== rpg/maps/overworld/table ===

$53798109572704* 这是张桌子……
$74345816549611* 桌子


=== trans/complete_unlocks ===


# When you have a circuit where the wires can settle in either of 2 different stable states, you have a basis for memory. The next state will depend on the values the wires had last tick. Such wires are called "latches".
$45250062735373* 解锁内容


=== components/FastRam ===

$79436020115192* 更快的内存，但是逻辑门开销更大
$12924829814634* 高速内存


=== levels/byte_xor ===

$19636386696963* 搭建一个电路，对两个单字节输入执行按位异或运算。


=== trans/view_solution_text ===

$83652444593618* 要查看本关参考解法的视频吗（需跳转到 Youtube）？


=== misc/add_bottom ===

$86446054110623* 添加


=== levels/Immediate Values ===

$64348543296709* 监视槽 {value} 应链接到输出设备
$14060810229477* 向电路图中添加 6 个寄存器
$79667526283284* 监视槽 {value} 应链接到计数器上
$14960344494328*
有时候，我们需要直接从程序代码而非寄存器中读取一个数。这种从代码中直接读出的数值被称为立即数。在 [color=#e49f44]LEG[/color] 架构中，我们可以在操作码（OPCODE）中定义立即数模式。更具体地说，我们可以用如下方式来指定哪个参数是立即数：

当操作码的第 8 位为 [ON] 时，将第一个参数作为立即数，而非理解为地址值。
当操作码的第 7 位为 [ON] 时，将第二个参数作为立即数，而非理解为地址值。
	
		[img]dialogue/leg_diagram_2_zh_CN.png[/img]
		
$10788301006338* 监视槽 {nr} 应链接到寄存器（或包含寄存器的自定义元件）上
$19338533633006* 将计数器增量设为 4
$15197362332657* 新建一份架构图，向图中添加一个有 4 路单字节输出的程序模块
$18004215603701* 往电路里加入一个计数器
$10141611261952* [center]加入立即数模式[/center]


=== components/switch ===

$87345192339084* 切换线路通断
$29301846684808* 8 位开关


=== levels/Wire Spaghetti ===

$29329105515650* 向电路图中再添加 1 个寄存器
$17106892574116* 往电路里加入一个计数器
$50177586789991* 向电路图中再添加 {nr} 个寄存器
$15754373587500* 将计数器增量设为 4
$56024330661504* 监视槽 {nr} 应链接到寄存器（或包含寄存器的自定义元件）上
$19099471819164*
下面是这一关开始时你需要做的一些准备工作：
		
[b]1.[/b] 点击“切换电路图”按钮（[b][i][/i][/b]），新建一份架构电路图。
[b]2.[/b] 往电路里添加一个带四路输出的程序元件。
[b]3.[/b] 添加 1 个计数器，将其步长设为 4，将它连接到程序元件的输入端上。
[b]4.[/b] 向电路里添加 6 个寄存器（或包含寄存器的自定义元件）。
[b]5.[/b] 点击程序元件上的“编辑监视态”，将编号为 0 到 5 的监视槽与刚才添加的寄存器链接起来，将 6 号监视槽链接到计数器上，将 7 号监视槽链接到关卡输出元件上。
$18860645759682*
[color=#e49f44]LEG[/color]是一种新的计算机架构，它每个时钟刻从程序存储器中读取 4 个字节并执行对应的命令。

第一个字节描述操作（称为操作码，[color=#e49f44]OPCODE[/color]）。

由于许多操作需要 2 个参数（如加法），所以第二个和第三个字节是用作命令参数的。

因为大多数操作都会返回 1 个结果，所以第四个字节是预留给计算结果的。
	
	[img]dialogue/leg_diagram_1_zh_CN.png[/img]
$11377431500625* 向电路图中添加 6 个寄存器
$14051336765362* 终于是时候让你构建 [color=#e49f44]LEG[/color] 体系了！
$13268807052125* （你可能作了 7+7 运算，但是这里的 7 表示你需要从输入组件中获取的值，这个值本身不一定为 7）
$30006055126224* 监视槽 {output} 应链接到输出设备
$19066122929275* [center]向电路中添加寄存器，然后实现加法操作（ADD）[/center]
$10912834168905*
请注意，这一关里操作码（[color=#e49f44]OPCODE[/color]）始终是 0。这意味着我们将对参数 1 和参数 2 做加法（ADD），并将结果发送到目标地址上。

命令的输入参数或输出参数都是地址值。地址值与元件的对应关系如下所示：
[code]
[color=#e49f44]0[/color]：0 号寄存器
[color=#e49f44]1[/color]：1 号寄存器
[color=#e49f44]2[/color]：2 号寄存器
[color=#e49f44]3[/color]：3 号寄存器
[color=#e49f44]4[/color]：4 号寄存器
[color=#e49f44]5[/color]：5 号寄存器
[color=#e49f44]6[/color]：计数器
[color=#e49f44]7[/color]：输入/输出元件
[/code]

在下一关，你将实现更多的操作码（[color=#e49f44]OPCODE[/color]），这就需要你新设计一个与 [color=#e49f44]OVERTURE[/color] 不同的算术逻辑单元（ALU）。
$10922418807673* 参数 7 表示从输入中获取数值，但是输入元件未启用。
$62258842382434* 监视槽 {counter} 应链接到计数器上
$18769284297247* 新建一份架构图，向图中添加一个有 4 路单字节输出的程序模块


=== trans/schematic_new_file_name ===

$24424463568668* 新建电路图


=== trans/negative_numbers ===

$57872971841486* 负数表示法


